<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>⏀ VEKTOR</title>
<!-- highlight.js for code syntax highlighting -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/ocean.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Geist+Mono:wght@300;400;500;600&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  /* Electron: make sidebar header draggable for native window controls */
  .electron-app .sidebar-header {
    -webkit-app-region: drag;
    padding-top: 52px;
  }
  .electron-app .sidebar.collapsed .sidebar-header {
    padding-top: 52px;
  }
  .electron-app .sidebar-header button,
  .electron-app .sidebar-header .new-thread-btn,
  .electron-app .sidebar-header .sidebar-collapse-btn,
  .electron-app .sidebar-header .sidebar-title,
  .electron-app .collapsed-new-thread-btn {
    -webkit-app-region: no-drag;
  }
  .electron-app .main-header {
    -webkit-app-region: drag;
  }
  .electron-app .main-header button,
  .electron-app .main-header select,
  .electron-app .main-header input,
  .electron-app .main-header a {
    -webkit-app-region: no-drag;
  }

  :root {
    --bg-primary: #1a1d23;
    --bg-secondary: rgba(26, 30, 38, 0.45);
    --bg-tertiary: rgba(255, 255, 255, 0.04);
    --bg-hover: rgba(255, 255, 255, 0.06);
    --border: rgba(255, 255, 255, 0.06);
    --border-subtle: rgba(255, 255, 255, 0.04);
    --text-primary: #e4e6ea;
    --text-secondary: #8b8f96;
    --text-tertiary: #555963;
    --accent: #8EC3E3;
    --accent-dim: #6A9DBD;
    --accent-glow: rgba(142, 195, 227, 0.08);
    --scrollbar-thumb: rgba(255, 255, 255, 0.1);
    --scrollbar-track: transparent;
    --user-bubble: rgba(255, 255, 255, 0.06);
  }

  html, body {
    height: 100%;
    background: transparent;
    color: var(--text-primary);
    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    font-size: 14px;
    font-weight: 400;
    overflow: hidden;
    -webkit-font-smoothing: antialiased;
    letter-spacing: -0.01em;
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: var(--scrollbar-track); }
  ::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: #3a3a3a; }

  /* Layout */
  .app {
    display: flex;
    height: 100vh;
  }

  /* ═══════════════════════════════
     NAV RAIL (48px vertical icon bar)
     ═══════════════════════════════ */

  .nav-rail {
    width: 48px;
    min-width: 48px;
    background: rgba(26, 30, 38, 0.65);
    backdrop-filter: blur(24px) saturate(1.4);
    -webkit-backdrop-filter: blur(24px) saturate(1.4);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 12px 0;
    z-index: 20;
    contain: layout style;
  }

  .nav-rail-top,
  .nav-rail-bottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
  }

  .nav-rail-btn {
    width: 36px;
    height: 36px;
    border-radius: 8px;
    border: none;
    background: none;
    color: var(--text-tertiary);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.15s;
    position: relative;
    isolation: isolate;
  }

  .nav-rail-btn::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 8px;
    opacity: 0;
    transition: opacity 0.15s;
    will-change: opacity;
    z-index: -1;
    pointer-events: none;
  }

  .nav-rail-btn:hover {
    color: var(--text-secondary);
  }

  .nav-rail-btn:hover::before {
    background: var(--bg-hover);
    opacity: 1;
  }

  .nav-rail-btn.active {
    color: var(--accent);
  }

  .nav-rail-btn.active::before {
    background: var(--accent-glow);
    opacity: 1;
  }

  .nav-rail-btn.active::before {
    content: '';
    position: absolute;
    left: -6px;
    top: 8px;
    bottom: 8px;
    width: 3px;
    background: var(--accent);
    border-radius: 0 2px 2px 0;
  }

  .nav-rail-btn svg {
    width: 18px;
    height: 18px;
  }

  .nav-rail-divider {
    width: 24px;
    height: 1px;
    background: var(--border);
    margin: 6px 0;
  }

  .nav-rail-logo {
    width: 36px;
    height: 36px;
    border-radius: 8px;
    border: none;
    background: none;
    color: var(--accent);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    transition: all 0.15s;
    margin-bottom: 4px;
  }

  .nav-rail-logo:hover {
    background: var(--accent-glow);
  }

  .nav-rail-notification-dot {
    position: absolute;
    top: 6px;
    right: 6px;
    width: 7px;
    height: 7px;
    background: #DC3545;
    border-radius: 50%;
    border: 1.5px solid var(--bg-primary);
  }

  .nav-rail-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 1.5px solid var(--accent-dim);
    background: var(--accent-glow);
    color: var(--accent);
    font-size: 13px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.15s;
  }

  .nav-rail-avatar:hover {
    border-color: var(--accent);
    background: rgba(142, 195, 227, 0.15);
  }

  .nav-rail-btn[data-tooltip]:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    left: 48px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(30, 34, 42, 0.95);
    color: var(--text-primary);
    padding: 4px 10px;
    border-radius: 6px;
    font-size: 12px;
    font-family: inherit;
    white-space: nowrap;
    z-index: 100;
    pointer-events: none;
    border: 1px solid var(--border);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }

  /* ─── Breadcrumb ─── */

  .breadcrumb {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 13px;
  }

  .breadcrumb-segment {
    color: var(--text-tertiary);
    cursor: pointer;
    transition: color 0.12s;
  }

  .breadcrumb-segment:hover {
    color: var(--text-primary);
  }

  .breadcrumb-separator {
    color: var(--text-tertiary);
    opacity: 0.4;
    font-size: 10px;
  }

  .breadcrumb-current {
    color: var(--text-secondary);
    cursor: default;
  }

  /* ─── Dashboard / Home view ─── */

  .dashboard-view {
    flex: 1;
    overflow-y: auto;
    padding: 48px 32px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .dashboard-inner {
    max-width: 680px;
    width: 100%;
  }

  .dashboard-welcome {
    text-align: center;
    margin-bottom: 40px;
  }

  .dashboard-glyph {
    font-size: 42px;
    color: var(--accent);
    margin-bottom: 12px;
  }

  .dashboard-title {
    font-size: 22px;
    font-weight: 400;
    color: var(--text-primary);
    margin-bottom: 6px;
  }

  .dashboard-subtitle {
    font-size: 13px;
    color: var(--text-tertiary);
  }

  .dashboard-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
    margin-bottom: 32px;
  }

  .stat-card {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px;
    text-align: center;
    cursor: pointer;
    transition: all 0.15s;
  }

  .stat-card:hover {
    background: var(--bg-hover);
    border-color: var(--accent-dim);
  }

  .stat-number {
    font-family: 'Geist Mono', monospace;
    font-size: 28px;
    font-weight: 300;
    color: var(--text-primary);
    margin-bottom: 4px;
  }

  .stat-label {
    font-size: 11px;
    color: var(--text-tertiary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .dashboard-section-title {
    font-family: 'Geist Mono', monospace;
    font-size: 11px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--text-tertiary);
    margin-bottom: 12px;
  }

  .dashboard-recent {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .recent-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 14px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.1s;
  }

  .recent-item:hover {
    background: var(--bg-hover);
  }

  .recent-icon {
    color: var(--text-tertiary);
    flex-shrink: 0;
  }

  .recent-icon svg {
    width: 16px;
    height: 16px;
  }

  .recent-text {
    font-size: 13px;
    color: var(--text-secondary);
  }

  .recent-time {
    margin-left: auto;
    font-size: 11px;
    color: var(--text-tertiary);
    flex-shrink: 0;
  }

  /* ─── Fade animation for view transitions ─── */

  .fade-in {
    animation: fadeIn 0.15s ease;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(4px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* Sidebar */
  .sidebar {
    width: 240px;
    min-width: 240px;
    background: var(--bg-secondary);
    backdrop-filter: blur(24px) saturate(1.4);
    -webkit-backdrop-filter: blur(24px) saturate(1.4);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1), min-width 0.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.15s ease;
    contain: layout style;
  }

  .sidebar.collapsed {
    width: 0;
    min-width: 0;
    border-right: none;
    opacity: 0;
    pointer-events: none;
  }

  .sidebar-header {
    padding: 20px 16px 12px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  /* (old collapsed sidebar-header styles removed - sidebar now collapses to 0) */

  .sidebar-title {
    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    font-size: 15px;
    font-weight: 300;
    letter-spacing: 0.22em;
    text-transform: uppercase;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 10px;
    white-space: nowrap;
    overflow: hidden;
  }

  /* (old collapsed title/chevron hide rules removed) */

  /* Agent selector dropdown */
  .sidebar-title {
    cursor: pointer;
    position: relative;
    user-select: none;
  }

  .agent-selector-chevron {
    font-size: 10px;
    color: var(--text-tertiary);
    transition: transform 0.15s;
    margin-left: -4px;
  }

  .sidebar-title.open .agent-selector-chevron {
    transform: rotate(180deg);
  }

  .agent-selector-glyph {
    font-size: 14px;
    color: var(--accent);
    flex-shrink: 0;
  }

  .agent-selector-dropdown {
    display: none;
    position: fixed;
    background: rgba(30, 34, 42, 0.95);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 4px;
    min-width: 170px;
    z-index: 9999;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    animation: dropdownIn 0.12s ease-out;
  }

  .agent-selector-dropdown.open {
    display: block;
  }

  .agent-selector-option {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 9px 12px;
    border-radius: 6px;
    cursor: pointer;
    border: none;
    background: none;
    width: 100%;
    text-align: left;
    color: var(--text-secondary);
    font-family: inherit;
    font-size: 12.5px;
    letter-spacing: 0.08em;
    transition: all 0.12s;
  }

  .agent-selector-option:hover {
    background: var(--bg-hover);
    color: var(--text-primary);
  }

  .agent-selector-option.active {
    color: var(--text-primary);
  }

  .agent-selector-option .as-glyph {
    font-size: 14px;
    width: 20px;
    text-align: center;
    flex-shrink: 0;
  }

  .agent-selector-option .as-check {
    margin-left: auto;
    font-size: 11px;
    color: var(--accent);
    opacity: 0;
  }

  .agent-selector-option.active .as-check {
    opacity: 1;
  }

  /* (glyph moved to main header right side) */

  /* Collapse toggle button */
  .sidebar-collapse-btn {
    background: none;
    border: none;
    color: var(--text-tertiary);
    cursor: pointer;
    font-size: 14px;
    padding: 4px;
    border-radius: 4px;
    transition: all 0.15s;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
  }

  .sidebar-collapse-btn:hover {
    color: var(--text-primary);
    background: var(--bg-hover);
  }

  /* (old collapsed btn/thread rules removed) */

  /* Collapsed new thread button at bottom of thread list */
  .collapsed-new-thread-btn {
    display: none;
    width: 32px;
    height: 32px;
    border-radius: 6px;
    background: none;
    border: none;
    color: var(--text-tertiary);
    cursor: pointer;
    font-size: 16px;
    align-items: center;
    justify-content: center;
    margin: 4px auto;
    transition: all 0.15s;
  }

  .collapsed-new-thread-btn:hover {
    background: var(--bg-hover);
    color: var(--text-primary);
  }

  .sidebar.collapsed .collapsed-new-thread-btn {
    display: flex;
  }

  /* Collapsed thread items */
  .sidebar.collapsed .thread-list {
    padding: 4px;
  }

  .sidebar.collapsed .thread-item {
    padding: 8px;
    justify-content: center;
    border-radius: 8px;
  }

  .sidebar.collapsed .thread-info {
    display: none;
  }

  .sidebar.collapsed .thread-actions {
    display: none !important;
  }

  .thread-icon {
    display: none;
    width: 32px;
    height: 32px;
    border-radius: 6px;
    background: var(--bg-tertiary);
    color: var(--text-secondary);
    font-family: 'Geist Mono', monospace;
    font-size: 11px;
    font-weight: 600;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    letter-spacing: 0;
    text-transform: uppercase;
  }

  .sidebar.collapsed .thread-icon {
    display: flex;
  }

  .thread-item.active .thread-icon {
    background: var(--accent-dim);
    color: var(--accent);
  }

  /* Collapsed footer */
  .sidebar.collapsed .sidebar-footer {
    padding: 12px 4px;
    text-align: center;
    font-size: 0;
  }

  .sidebar.collapsed .sidebar-footer .status-dot {
    margin-right: 0;
  }

  .sidebar.collapsed .sidebar-footer .footer-text {
    display: none;
  }

  /* ═══════════════════════════════════════════ */
  /* New Thread Dropdown                         */
  /* ═══════════════════════════════════════════ */
  .new-thread-container {
    position: relative;
  }

  .new-thread-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    width: 28px;
    height: 28px;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    transition: all 0.15s;
  }

  .new-thread-btn:hover {
    background: var(--bg-hover);
    color: var(--text-primary);
  }

  .new-thread-dropdown {
    display: none;
    position: absolute;
    top: calc(100% + 6px);
    right: 0;
    background: rgba(30, 34, 42, 0.95);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 4px;
    min-width: 200px;
    z-index: 100;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    animation: dropdownIn 0.12s ease-out;
  }

  .new-thread-dropdown.open {
    display: block;
  }

  @keyframes dropdownIn {
    from { opacity: 0; transform: translateY(-4px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .new-thread-option {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    border-radius: 6px;
    cursor: pointer;
    border: none;
    background: none;
    width: 100%;
    text-align: left;
    color: var(--text-secondary);
    font-family: inherit;
    font-size: 12.5px;
    transition: all 0.12s;
  }

  .new-thread-option:hover {
    background: var(--bg-hover);
    color: var(--text-primary);
  }

  .new-thread-option .option-glyph {
    font-size: 14px;
    width: 24px;
    text-align: center;
    flex-shrink: 0;
  }

  .new-thread-option .option-glyph.amber { color: var(--accent); }
  .new-thread-option .option-glyph.blue-slate { color: #7b8fb0; }
  .new-thread-option .option-glyph.dual { 
    color: var(--text-tertiary);
    font-size: 12px;
    letter-spacing: 1px;
  }

  .new-thread-option .option-label {
    font-weight: 500;
  }

  .new-thread-option .option-desc {
    font-size: 10px;
    color: var(--text-tertiary);
    margin-top: 1px;
  }

  .thread-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
    contain: layout style;
  }

  .thread-item {
    padding: 10px 12px;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 2px;
    position: relative;
    isolation: isolate;
    contain: layout style;
  }

  /* Use a pseudo-element for hover background — avoids repainting the
     sidebar backdrop-filter layer on every hover state change. The
     pseudo-element lives on its own compositor layer (will-change: opacity)
     so toggling it is a GPU-only operation with zero reflow/repaint. */
  .thread-item::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 6px;
    background: var(--bg-hover);
    opacity: 0;
    transition: opacity 0.12s;
    will-change: opacity;
    z-index: -1;
    pointer-events: none;
  }

  .thread-item:hover::before {
    opacity: 1;
  }

  .thread-item.active::before {
    opacity: 1;
  }

  .thread-name {
    font-size: 12.5px;
    color: var(--text-secondary);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
  }

  .thread-item.active .thread-name {
    color: var(--text-primary);
  }

  /* Group thread indicator */
  .thread-mode-badge {
    font-size: 10px;
    margin-right: 6px;
    flex-shrink: 0;
    letter-spacing: 1px;
    color: var(--text-tertiary);
    font-family: 'Geist Mono', monospace;
  }

  .thread-actions {
    display: flex;
    gap: 4px;
    margin-left: 8px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.12s;
  }

  .thread-item:hover .thread-actions {
    opacity: 1;
    pointer-events: auto;
  }

  .thread-action-btn {
    background: none;
    border: none;
    color: var(--text-tertiary);
    cursor: pointer;
    font-size: 11px;
    padding: 2px 4px;
    border-radius: 3px;
    transition: color 0.12s, opacity 0.12s;
    position: relative;
  }

  .thread-action-btn::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 3px;
    background: var(--bg-hover);
    opacity: 0;
    transition: opacity 0.12s;
    pointer-events: none;
  }

  .thread-action-btn:hover {
    color: var(--text-primary);
  }

  .thread-action-btn:hover::before {
    opacity: 1;
  }

  .thread-action-btn.delete:hover {
    color: #c44;
  }

  .thread-action-btn.resume:hover {
    color: var(--accent);
  }

  .thread-meta {
    font-size: 10px;
    color: var(--text-tertiary);
    margin-top: 2px;
  }

  .thread-info {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-width: 0;
  }

  /* Sidebar footer */
  .sidebar-footer {
    padding: 12px 16px;
    font-family: 'Geist Mono', monospace;
    font-size: 10px;
    color: var(--text-tertiary);
    letter-spacing: 0.05em;
  }

  .status-dot {
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #4a7;
    margin-right: 6px;
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  /* Main area */
  .main {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: rgba(26, 29, 35, 0.92);
    min-width: 0;
  }

  .main-header {
    padding: 14px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    min-height: 48px;
  }

  .main-header-title {
    font-size: 13px;
    font-weight: 400;
    color: var(--text-secondary);
    letter-spacing: 0.04em;
  }

  /* Group header with participant glyphs */
  .main-header-participants {
    display: flex;
    align-items: center;
    gap: 6px;
    font-family: 'Geist Mono', monospace;
    font-size: 11px;
    letter-spacing: 0.05em;
  }

  .participant-tag {
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  .participant-separator {
    color: var(--text-tertiary);
    font-size: 10px;
  }

  .main-header-glyph {
    font-size: 18px;
    color: var(--accent);
    opacity: 0.7;
    line-height: 1;
  }

  /* Agent conversation tabs */
  .agent-tabs {
    display: flex;
    padding: 0 16px;
    gap: 2px;
    border-bottom: 1px solid var(--border);
    background: rgba(26, 29, 35, 0.6);
    min-height: 0;
    overflow: hidden;
  }

  .agent-tabs:empty {
    display: none;
  }

  .agent-tab {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 14px;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.15s;
    font-size: 11.5px;
    font-family: 'Geist Mono', monospace;
    letter-spacing: 0.04em;
    color: var(--text-tertiary);
    white-space: nowrap;
    user-select: none;
  }

  .agent-tab:hover {
    color: var(--text-secondary);
    background: var(--bg-hover);
  }

  .agent-tab.active {
    color: var(--text-primary);
    border-bottom-color: var(--accent);
  }

  .agent-tab-glyph {
    font-size: 13px;
    flex-shrink: 0;
  }

  .agent-tab-name {
    font-weight: 500;
    text-transform: uppercase;
  }

  .agent-tab-thread {
    color: var(--text-tertiary);
    font-size: 10.5px;
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
    opacity: 0.7;
  }

  .agent-tab-thread::before {
    content: '/ ';
    opacity: 0.4;
  }

  /* Messages area */
  .messages {
    flex: 1;
    overflow-y: auto;
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .message {
    max-width: 800px;
    width: 100%;
    margin: 0 auto;
    display: flex;
    gap: 14px;
    animation: fadeIn 0.2s ease-out;
    position: relative;
    padding: 12px 14px;
    border-radius: 10px;
  }

  .message.user {
    background: var(--user-bubble);
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(4px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .message-avatar {
    width: 28px;
    height: 28px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    flex-shrink: 0;
    margin-top: 2px;
  }

  .message.user .message-avatar {
    background: var(--bg-tertiary);
    color: var(--text-secondary);
  }

  .message.assistant .message-avatar {
    background: var(--accent-glow);
    color: var(--accent);
  }

  /* Agent-specific avatar colors for group chat */
  .message.assistant.agent-main .message-avatar {
    background: rgba(142, 195, 227, 0.08);
    color: #8EC3E3;
  }

  .message.assistant.agent-anima .message-avatar {
    background: rgba(123, 143, 176, 0.08);
    color: #7b8fb0;
  }

  .message-content {
    flex: 1;
    min-width: 0;
    overflow-x: hidden;
    overflow-y: visible;
  }

  .message-role {
    font-size: 11px;
    font-weight: 500;
    letter-spacing: 0.05em;
    margin-bottom: 6px;
  }

  .message.user .message-role { color: var(--text-tertiary); }
  .message.assistant .message-role { color: var(--accent-dim); }

  /* Agent-specific role colors */
  .message.assistant.agent-main .message-role { color: #6A9DBD; }
  .message.assistant.agent-anima .message-role { color: #556b8a; }

  /* ═══════════════════════════════════════════ */
  /* Message Timestamp (hover-reveal)            */
  /* ═══════════════════════════════════════════ */
  .message-timestamp {
    font-size: 10px;
    color: var(--text-tertiary);
    font-family: 'Geist Mono', monospace;
    letter-spacing: 0.03em;
    margin-left: 8px;
    opacity: 0;
    transition: opacity 0.2s;
    user-select: none;
  }

  .message:hover .message-timestamp {
    opacity: 1;
  }

  .message-role-row {
    display: flex;
    align-items: center;
  }

  /* ═══════════════════════════════════════════ */
  /* Message Actions (hover bar)                 */
  /* ═══════════════════════════════════════════ */
  .message-actions {
    position: absolute;
    top: -8px;
    right: 0;
    display: flex;
    gap: 2px;
    padding: 3px 4px;
    background: rgba(30, 34, 42, 0.92);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border-radius: 8px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.15s;
    z-index: 10;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
  }

  .message:hover .message-actions {
    opacity: 1;
    pointer-events: auto;
  }

  .msg-action-btn {
    background: none;
    border: none;
    color: var(--text-tertiary);
    cursor: pointer;
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 4px;
    transition: all 0.12s;
    font-family: 'Geist Mono', monospace;
    letter-spacing: 0.03em;
    white-space: nowrap;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .msg-action-btn:hover {
    color: var(--text-primary);
    background: var(--bg-hover);
  }

  .msg-action-btn.delete:hover {
    color: #c44;
  }

  .msg-action-btn svg {
    width: 13px;
    height: 13px;
    stroke: currentColor;
    fill: none;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  /* ═══════════════════════════════════════════ */
  /* Message Text & Markdown Rendering           */
  /* ═══════════════════════════════════════════ */
  .message-text {
    font-size: 14px;
    line-height: 1.7;
    color: var(--text-primary);
    word-wrap: break-word;
    overflow-wrap: break-word;
    font-weight: 400;
  }

  .message-text p { margin-bottom: 12px; }
  .message-text p:last-child { margin-bottom: 0; }

  /* Inline code */
  .message-text code:not(.hljs):not(.code-block-code) {
    font-family: 'Geist Mono', monospace;
    background: rgba(255, 255, 255, 0.07);
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 12.5px;
    color: var(--accent);
  }

  /* ═══════════════════════════════════════════ */
  /* Code Blocks (World-Class)                   */
  /* ═══════════════════════════════════════════ */
  .code-block-wrapper {
    position: relative;
    margin: 12px 0;
    border-radius: 10px;
    overflow: hidden;
    background: rgba(0, 0, 0, 0.25);
  }

  .code-block-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: rgba(0, 0, 0, 0.15);
    min-height: 36px;
  }

  .code-block-lang {
    font-family: 'Geist Mono', monospace;
    font-size: 10px;
    letter-spacing: 0.08em;
    color: var(--text-tertiary);
    text-transform: uppercase;
    font-weight: 500;
  }

  .code-block-actions {
    display: flex;
    gap: 4px;
    align-items: center;
  }

  .code-action-btn {
    background: none;
    border: 1px solid transparent;
    color: var(--text-tertiary);
    padding: 3px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 10px;
    font-family: 'Geist Mono', monospace;
    transition: all 0.15s;
    display: flex;
    align-items: center;
    gap: 4px;
    letter-spacing: 0.03em;
  }

  .code-action-btn:hover {
    background: var(--bg-hover);
    color: var(--text-primary);
    border-color: var(--border);
  }

  .code-action-btn.copied {
    color: var(--accent);
    border-color: var(--accent-dim);
  }

  .code-action-btn svg {
    width: 12px;
    height: 12px;
    stroke: currentColor;
    fill: none;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .code-block-body {
    display: flex;
    max-height: 480px;
    overflow: auto;
  }

  .code-block-body::-webkit-scrollbar { width: 6px; height: 6px; }
  .code-block-body::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }

  /* Line numbers gutter */
  .code-line-numbers {
    padding: 14px 0;
    text-align: right;
    user-select: none;
    color: #3a3f47;
    font-family: 'Geist Mono', monospace;
    font-size: 12px;
    line-height: 1.5;
    min-width: 40px;
    padding-right: 12px;
    padding-left: 12px;
    border-right: 1px solid #1a1f27;
    flex-shrink: 0;
  }

  .code-line-numbers span {
    display: block;
  }

  .code-block-code {
    flex: 1;
    margin: 0;
    padding: 14px 16px;
    font-family: 'Geist Mono', monospace;
    font-size: 13px;
    line-height: 1.5;
    background: transparent !important;
    border: none;
    overflow: visible;
    white-space: pre;
    color: var(--text-primary);
  }

  .code-block-code code {
    font-family: 'Geist Mono', monospace;
    background: none !important;
    border: none !important;
    padding: 0 !important;
    font-size: inherit;
    color: inherit;
  }

  /* Override highlight.js theme to match our dark aesthetic */
  .code-block-code .hljs { background: transparent !important; color: #cccccc; padding: 0; }
  .code-block-code .hljs-keyword { color: #8EC3E3; }
  .code-block-code .hljs-string { color: #a5d6a7; }
  .code-block-code .hljs-number { color: #e6b07c; }
  .code-block-code .hljs-comment { color: #546e7a; font-style: italic; }
  .code-block-code .hljs-function { color: #c9d1d9; }
  .code-block-code .hljs-title { color: #e0c097; }
  .code-block-code .hljs-title.function_ { color: #e0c097; }
  .code-block-code .hljs-params { color: #c9d1d9; }
  .code-block-code .hljs-built_in { color: #b8937a; }
  .code-block-code .hljs-literal { color: #e6b07c; }
  .code-block-code .hljs-type { color: #c4a882; }
  .code-block-code .hljs-attr { color: #8EC3E3; }
  .code-block-code .hljs-property { color: #c9d1d9; }
  .code-block-code .hljs-variable { color: #c9d1d9; }
  .code-block-code .hljs-variable.language_ { color: #8EC3E3; }
  .code-block-code .hljs-operator { color: #e6b07c; }
  .code-block-code .hljs-punctuation { color: #6a737d; }
  .code-block-code .hljs-meta { color: #6A9DBD; }
  .code-block-code .hljs-meta .hljs-keyword { color: #6A9DBD; }
  .code-block-code .hljs-regexp { color: #a5d6a7; }
  .code-block-code .hljs-selector-tag { color: #8EC3E3; }
  .code-block-code .hljs-selector-class { color: #e0c097; }
  .code-block-code .hljs-selector-id { color: #e0c097; }
  .code-block-code .hljs-tag { color: #8EC3E3; }
  .code-block-code .hljs-name { color: #8EC3E3; }
  .code-block-code .hljs-attribute { color: #e0c097; }
  .code-block-code .hljs-symbol { color: #e6b07c; }
  .code-block-code .hljs-bullet { color: #8EC3E3; }
  .code-block-code .hljs-addition { color: #a5d6a7; }
  .code-block-code .hljs-deletion { color: #c44; }
  .code-block-code .hljs-section { color: #e0c097; font-weight: 600; }
  .code-block-code .hljs-emphasis { font-style: italic; }
  .code-block-code .hljs-strong { font-weight: 700; }

  /* Remove old pre styling — code blocks are now wrapped */
  .message-text pre {
    background: transparent;
    border: none;
    border-radius: 0;
    padding: 0;
    margin: 0;
    overflow: visible;
  }

  .message-text pre code {
    font-family: 'Geist Mono', monospace;
    background: none;
    border: none;
    padding: 0;
    font-size: inherit;
  }

  .message-text strong { color: var(--text-primary); font-weight: 600; }
  .message-text em { color: var(--text-secondary); font-style: italic; }
  .message-text del { color: var(--text-tertiary); text-decoration: line-through; }

  .message-text ul, .message-text ol {
    margin: 8px 0;
    padding-left: 24px;
  }

  .message-text li { margin-bottom: 4px; line-height: 1.6; }
  .message-text li ul, .message-text li ol { margin: 4px 0; }

  /* Task list checkboxes */
  .message-text li.task-item {
    list-style: none;
    margin-left: -24px;
    padding-left: 4px;
  }

  .message-text li.task-item input[type="checkbox"] {
    margin-right: 8px;
    accent-color: var(--accent);
    vertical-align: middle;
  }

  .message-text blockquote {
    border-left: 3px solid var(--accent-dim);
    padding: 8px 14px;
    margin: 10px 0;
    color: var(--text-secondary);
    background: rgba(142, 195, 227, 0.03);
    border-radius: 0 6px 6px 0;
  }

  .message-text blockquote blockquote {
    margin: 8px 0;
    border-left-color: var(--border);
  }

  .message-text h1, .message-text h2, .message-text h3, .message-text h4, .message-text h5, .message-text h6 {
    margin: 16px 0 8px;
    color: var(--text-primary);
    line-height: 1.3;
  }
  .message-text h1 { font-size: 18px; font-weight: 600; }
  .message-text h2 { font-size: 16px; font-weight: 600; }
  .message-text h3 { font-size: 15px; color: var(--accent); font-weight: 500; }
  .message-text h4 { font-size: 14px; color: var(--text-secondary); font-weight: 500; }
  .message-text h5 { font-size: 13px; color: var(--text-secondary); font-weight: 500; }
  .message-text h6 { font-size: 12px; color: var(--text-tertiary); font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }

  /* Tables */
  .message-text .table-wrapper {
    overflow-x: auto;
    margin: 12px 0;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.15);
  }

  .message-text table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
    border: none;
    border-radius: 0;
  }

  .message-text th {
    text-align: left;
    padding: 8px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    color: var(--text-primary);
    font-weight: 600;
    background: rgba(0, 0, 0, 0.1);
    font-size: 12px;
    letter-spacing: 0.03em;
  }

  .message-text td {
    padding: 6px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.03);
    color: var(--text-secondary);
  }

  .message-text tr:nth-child(even) td {
    background: rgba(255, 255, 255, 0.015);
  }

  .message-text tr:last-child td {
    border-bottom: none;
  }

  .message-text a {
    color: var(--accent);
    text-decoration: none;
  }
  .message-text a:hover { text-decoration: underline; }

  .message-text hr {
    border: none;
    border-top: 1px solid var(--border);
    margin: 16px 0;
  }

  .message-text img:not(.message-image) {
    max-width: 100%;
    border-radius: 6px;
    margin: 8px 0;
    display: block;
  }

  /* Streaming cursor */
  .streaming-cursor::after {
    content: '▊';
    animation: blink 0.8s infinite;
    color: var(--accent);
    margin-left: 2px;
  }

  /* Agent-specific streaming cursors */
  .streaming-cursor.cursor-main::after { color: #8EC3E3; }
  .streaming-cursor.cursor-anima::after { color: #7b8fb0; }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  /* ═══════════════════════════════════════════ */
  /* Input area                                  */
  /* ═══════════════════════════════════════════ */
  .input-area {
    padding: 16px 24px 20px;
  }

  .input-wrapper {
    max-width: 800px;
    margin: 0 auto;
    display: flex;
    gap: 10px;
    align-items: flex-end;
    position: relative;
  }

  .input-box {
    flex: 1;
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 10px;
    padding: 12px 16px;
    padding-bottom: 12px;
    color: var(--text-primary);
    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    font-size: 14px;
    resize: none;
    outline: none;
    min-height: 44px;
    max-height: 200px;
    line-height: 1.5;
    transition: border-color 0.2s;
  }

  .input-box:focus {
    border-color: rgba(255, 255, 255, 0.15);
  }

  .input-box::placeholder {
    color: var(--text-tertiary);
  }

  /* Character count — positioned over bottom-right of textarea */
  .char-count {
    position: absolute;
    bottom: 8px;
    right: 62px;
    font-family: 'Geist Mono', monospace;
    font-size: 10px;
    color: var(--text-tertiary);
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
    letter-spacing: 0.03em;
    z-index: 1;
  }

  .char-count.visible {
    opacity: 0.6;
  }

  .char-count.warn {
    color: #c44;
    opacity: 1;
  }

  .send-btn {
    background: rgba(255, 255, 255, 0.06);
    border: none;
    color: var(--text-secondary);
    width: 44px;
    height: 44px;
    border-radius: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    transition: all 0.15s;
    flex-shrink: 0;
  }

  .send-btn:hover:not(:disabled) {
    background: rgba(255, 255, 255, 0.1);
    color: var(--text-primary);
  }

  .send-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }

  /* Stop generation button */
  .send-btn.stop-btn {
    background: rgba(204, 68, 68, 0.12);
    color: #c44;
    opacity: 1;
  }

  .send-btn.stop-btn:hover {
    background: rgba(204, 68, 68, 0.2);
  }

  /* ═══════════════════════════════════════════ */
  /* Typing Indicator                            */
  /* ═══════════════════════════════════════════ */
  .typing-indicator {
    display: none;
    max-width: 800px;
    margin: 0 auto;
    padding: 0 0 8px 0;
    font-size: 12px;
    color: var(--text-tertiary);
    font-family: 'Geist Mono', monospace;
    letter-spacing: 0.03em;
    align-items: center;
    gap: 8px;
  }

  .typing-indicator.active {
    display: flex;
  }

  .typing-dots {
    display: flex;
    gap: 3px;
    align-items: center;
  }

  .typing-dots span {
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background: var(--accent-dim);
    animation: typingDot 1.4s ease-in-out infinite;
  }

  .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
  .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

  @keyframes typingDot {
    0%, 60%, 100% { opacity: 0.3; transform: translateY(0); }
    30% { opacity: 1; transform: translateY(-2px); }
  }

  /* ═══════════════════════════════════════════ */
  /* Context Health Indicator                    */
  /* ═══════════════════════════════════════════ */
  .context-health-bar {
    max-width: 800px;
    margin: 0 auto;
    padding: 0 0 8px 0;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 11px;
    font-family: 'Geist Mono', monospace;
    letter-spacing: 0.03em;
  }

  .context-health-dot {
    font-size: 8px;
    line-height: 1;
  }

  .context-health-dot.green { color: #4a7; }
  .context-health-dot.yellow { color: #da6; }
  .context-health-dot.orange { color: #e95; }
  .context-health-dot.red { color: #c44; }

  .context-health-text {
    color: var(--text-tertiary);
  }

  /* ═══════════════════════════════════════════ */
  /* Toast Notification                          */
  /* ═══════════════════════════════════════════ */
  /* ═══════════════════════════════════════════ */
  /* Notification System                          */
  /* ═══════════════════════════════════════════ */

  .notification-bell {
    position: relative;
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s;
    -webkit-app-region: no-drag;
  }
  .notification-bell:hover { color: var(--text-primary); }
  .notification-bell.has-unread { color: var(--accent, #8EC3E3); }

  .notification-badge {
    position: absolute;
    top: 0;
    right: 0;
    background: #DC3545;
    color: #ffffff;
    font-size: 9px;
    font-weight: 700;
    font-family: 'Geist Mono', monospace;
    min-width: 14px;
    height: 14px;
    border-radius: 7px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 3px;
    line-height: 1;
    opacity: 0;
    transform: scale(0.5);
    transition: opacity 0.2s, transform 0.2s;
    pointer-events: none;
  }
  .notification-bell.has-unread .notification-badge {
    opacity: 1;
    transform: scale(1);
  }

  .notification-panel {
    position: fixed;
    width: 320px;
    max-height: min(420px, calc(100vh - 24px));
    background: #111318;
    border: 1px solid #2a2a2a;
    border-radius: 8px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.7), 0 0 0 1px rgba(0,0,0,0.3);
    z-index: 10000;
    display: none;
    flex-direction: column;
    overflow: hidden;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
    opacity: 0;
    transform: translateY(8px);
    transition: opacity 0.15s ease, transform 0.15s ease;
  }
  .notification-panel.visible { display: flex; }
  .notification-panel.open {
    opacity: 1;
    transform: translateY(0);
  }

  .notification-panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 14px;
    border-bottom: 1px solid #2a2a2a;
    background: #111318;
    font-size: 11px;
    font-family: 'Geist Mono', monospace;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: var(--text-secondary);
  }
  .notification-panel-header button {
    background: none;
    border: none;
    color: var(--text-tertiary, #555);
    cursor: pointer;
    font-size: 10px;
    font-family: 'Geist Mono', monospace;
    letter-spacing: 0.04em;
    padding: 2px 6px;
    border-radius: 4px;
    transition: color 0.15s, background 0.15s;
  }
  .notification-panel-header button:hover {
    color: var(--text-primary);
    background: rgba(255,255,255,0.05);
  }

  .notification-list {
    overflow-y: auto;
    flex: 1;
    padding: 4px 0;
    background: #111318;
  }

  .notification-item {
    display: flex;
    gap: 10px;
    padding: 10px 14px;
    cursor: pointer;
    transition: background 0.15s;
    border-left: 2px solid transparent;
  }
  .notification-item:hover { background: rgba(255,255,255,0.03); }
  .notification-item.unread {
    border-left-color: var(--accent, #8EC3E3);
    background: rgba(212,165,116,0.04);
  }

  .notification-icon {
    flex-shrink: 0;
    width: 28px;
    height: 28px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    background: rgba(255,255,255,0.05);
    color: var(--text-secondary);
  }
  .notification-item.unread .notification-icon {
    background: rgba(212,165,116,0.12);
    color: var(--accent, #8EC3E3);
  }

  .notification-content {
    flex: 1;
    min-width: 0;
  }
  .notification-title {
    font-size: 12px;
    color: var(--text-primary);
    margin-bottom: 2px;
    line-height: 1.3;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .notification-body {
    font-size: 11px;
    color: var(--text-secondary);
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  .notification-time {
    font-size: 9px;
    color: var(--text-tertiary, #555);
    margin-top: 3px;
    font-family: 'Geist Mono', monospace;
    letter-spacing: 0.03em;
  }

  .notification-empty {
    padding: 32px 14px;
    text-align: center;
    color: var(--text-tertiary, #555);
    font-size: 11px;
    font-family: 'Geist Mono', monospace;
  }
  .notification-empty-icon {
    font-size: 24px;
    margin-bottom: 8px;
    opacity: 0.4;
  }

  /* Pulse animation for new notifications */
  @keyframes notifPulse {
    0% { box-shadow: 0 0 0 0 rgba(212,165,116,0.4); }
    70% { box-shadow: 0 0 0 6px rgba(212,165,116,0); }
    100% { box-shadow: 0 0 0 0 rgba(212,165,116,0); }
  }
  .notification-bell.pulse { animation: notifPulse 0.6s ease-out; }

  .toast-container {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1100;
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
    pointer-events: none;
  }

  .toast {
    background: rgba(30, 34, 42, 0.92);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    color: var(--text-primary);
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 12px;
    font-family: 'Geist Mono', monospace;
    letter-spacing: 0.03em;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    animation: toastIn 0.2s ease-out, toastOut 0.2s ease-in 1.8s forwards;
    pointer-events: auto;
  }

  @keyframes toastIn {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
  }

  @keyframes toastOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }

  /* ═══════════════════════════════════════════ */
  /* Edit Message Textarea                       */
  /* ═══════════════════════════════════════════ */
  .edit-message-area {
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: var(--text-primary);
    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    font-size: 14px;
    line-height: 1.6;
    padding: 10px 14px;
    border-radius: 8px;
    width: 100%;
    min-height: 60px;
    max-height: 300px;
    resize: vertical;
    outline: none;
  }

  .edit-message-actions {
    display: flex;
    gap: 8px;
    margin-top: 8px;
  }

  .edit-msg-btn {
    background: rgba(255, 255, 255, 0.06);
    border: none;
    color: var(--text-secondary);
    padding: 5px 14px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    font-family: 'Geist Mono', monospace;
    transition: all 0.15s;
    letter-spacing: 0.03em;
  }

  .edit-msg-btn:hover {
    color: var(--text-primary);
    background: rgba(255, 255, 255, 0.1);
  }

  .edit-msg-btn.save {
    color: var(--accent);
  }

  .edit-msg-btn.save:hover {
    background: var(--accent-glow);
  }

  /* ═══════════════════════════════════════════ */
  /* Delete Confirmation                         */
  /* ═══════════════════════════════════════════ */
  .confirm-overlay {
    position: fixed;
    inset: 0;
    z-index: 1050;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.15s;
  }

  .confirm-dialog {
    background: rgba(30, 34, 42, 0.95);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 12px;
    padding: 20px 24px;
    max-width: 340px;
    width: 90%;
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
  }

  .confirm-dialog h3 {
    font-size: 14px;
    color: var(--text-primary);
    margin-bottom: 8px;
    font-weight: 500;
  }

  .confirm-dialog p {
    font-size: 12px;
    color: var(--text-secondary);
    margin-bottom: 16px;
    line-height: 1.5;
  }

  .confirm-dialog .confirm-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
  }

  .confirm-dialog .confirm-btn {
    padding: 6px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    font-family: 'Geist Mono', monospace;
    transition: all 0.15s;
    border: none;
  }

  .confirm-dialog .confirm-btn.cancel {
    background: rgba(255, 255, 255, 0.06);
    color: var(--text-secondary);
  }

  .confirm-dialog .confirm-btn.cancel:hover {
    background: rgba(255, 255, 255, 0.1);
    color: var(--text-primary);
  }

  .confirm-dialog .confirm-btn.danger {
    background: rgba(204, 68, 68, 0.1);
    border-color: #c44;
    color: #c44;
  }

  .confirm-dialog .confirm-btn.danger:hover {
    background: rgba(204, 68, 68, 0.2);
  }

  /* Upload & Attachments */
  .input-actions {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 0 0 8px 0;
    max-width: 800px;
    margin: 0 auto;
  }

  .upload-btn {
    background: none;
    border: 1px solid transparent;
    color: var(--text-tertiary);
    width: 36px;
    height: 36px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    transition: all 0.15s;
    flex-shrink: 0;
  }

  .upload-btn:hover {
    color: var(--text-secondary);
    background: var(--bg-tertiary);
    border-color: var(--border-subtle);
  }

  .upload-btn svg {
    width: 20px;
    height: 20px;
    stroke: currentColor;
    fill: none;
    stroke-width: 1.8;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .attachment-preview {
    display: none;
    flex-wrap: wrap;
    gap: 8px;
    padding: 8px 0;
    max-width: 800px;
    margin: 0 auto;
  }

  .attachment-preview.has-items {
    display: flex;
  }

  .attachment-item {
    position: relative;
    border-radius: 8px;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.04);
    transition: background 0.15s;
  }

  .attachment-item:hover {
    background: rgba(255, 255, 255, 0.07);
  }

  .attachment-item.image {
    width: 80px;
    height: 80px;
  }

  .attachment-item.image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }

  .attachment-item.file {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    max-width: 220px;
  }

  .attachment-file-icon {
    font-size: 16px;
    color: var(--text-tertiary);
    flex-shrink: 0;
  }

  .attachment-file-info {
    overflow: hidden;
  }

  .attachment-file-name {
    font-size: 12px;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .attachment-file-size {
    font-size: 10px;
    color: var(--text-tertiary);
    font-family: 'Geist Mono', monospace;
  }

  .attachment-remove {
    position: absolute;
    top: -6px;
    right: -6px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: rgba(30, 34, 42, 0.9);
    border: none;
    color: var(--text-secondary);
    font-size: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
    z-index: 2;
  }

  .attachment-remove:hover {
    background: #c44;
    color: #fff;
    border-color: #c44;
  }

  /* Drag & drop overlay */
  .drop-overlay {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 999;
    background: rgba(22, 22, 22, 0.9);
    border: 2px dashed var(--accent-dim);
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 12px;
    pointer-events: none;
  }

  .drop-overlay.active {
    display: flex;
  }

  .drop-overlay-icon {
    font-size: 48px;
    color: var(--accent);
    opacity: 0.6;
  }

  .drop-overlay-text {
    font-size: 16px;
    color: var(--text-secondary);
    letter-spacing: 0.05em;
  }

  /* Inline images in messages */
  .message-image {
    max-width: 400px;
    max-height: 400px;
    border-radius: 10px;
    border: 1px solid var(--border-subtle);
    margin: 0;
    cursor: pointer;
    transition: opacity 0.15s;
    display: block;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
  }

  /* Image container with hover overlay */
  .message-image-container {
    position: relative;
    display: inline-block;
    border-radius: 10px;
    overflow: hidden;
    margin: 8px 0;
  }

  .message-image-container.loading::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 10px;
    background: linear-gradient(90deg,
      rgba(255,255,255,0.03) 25%,
      rgba(255,255,255,0.08) 50%,
      rgba(255,255,255,0.03) 75%
    );
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    z-index: 1;
  }

  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }

  .message-image-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.45);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.15s;
    border-radius: 10px;
  }

  .message-image-container:hover .message-image-overlay {
    opacity: 1;
    pointer-events: auto;
  }

  .image-overlay-btn {
    width: 32px;
    height: 32px;
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    background: rgba(30, 34, 42, 0.7);
    color: rgba(255, 255, 255, 0.9);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.12s;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }

  .image-overlay-btn:hover {
    background: rgba(60, 65, 75, 0.9);
    transform: scale(1.08);
  }

  .image-overlay-btn svg {
    width: 14px;
    height: 14px;
    stroke: currentColor;
    fill: none;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .message-file-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    background: rgba(255, 255, 255, 0.04);
    border: none;
    border-radius: 6px;
    font-size: 12px;
    color: var(--text-secondary);
    margin: 4px 0;
    font-family: 'Geist Mono', monospace;
  }

  .message-file-badge svg {
    width: 14px;
    height: 14px;
    stroke: currentColor;
    fill: none;
    stroke-width: 1.8;
  }

  /* Image lightbox */
  .lightbox {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 1000;
    background: rgba(0, 0, 0, 0.92);
    align-items: center;
    justify-content: center;
    cursor: zoom-out;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }

  .lightbox.active {
    display: flex;
    animation: lightboxFadeIn 0.2s ease-out;
  }

  @keyframes lightboxFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .lightbox img {
    max-width: 90vw;
    max-height: 85vh;
    border-radius: 6px;
    box-shadow: 0 8px 60px rgba(0, 0, 0, 0.6);
    animation: lightboxZoomIn 0.25s cubic-bezier(0.16, 1, 0.3, 1);
    user-select: none;
  }

  @keyframes lightboxZoomIn {
    from { transform: scale(0.92); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .lightbox-toolbar {
    position: absolute;
    top: 16px;
    right: 16px;
    display: flex;
    gap: 8px;
    z-index: 1001;
  }

  .lightbox-btn {
    width: 36px;
    height: 36px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    background: rgba(30, 34, 42, 0.8);
    color: var(--text-secondary);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
  }

  .lightbox-btn:hover {
    background: rgba(60, 65, 75, 0.9);
    color: var(--text-primary);
    border-color: rgba(255, 255, 255, 0.25);
  }

  .lightbox-btn svg {
    width: 16px;
    height: 16px;
    stroke: currentColor;
    fill: none;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .lightbox-counter {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: var(--text-tertiary);
    font-size: 12px;
    font-family: 'Geist Mono', monospace;
    letter-spacing: 0.1em;
    background: rgba(30, 34, 42, 0.7);
    padding: 4px 12px;
    border-radius: 12px;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }

  /* Empty state */
  .empty-state {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: var(--text-tertiary);
    gap: 12px;
  }

  .empty-glyph {
    font-size: 48px;
    opacity: 0.15;
    color: var(--accent);
  }

  .empty-text {
    font-size: 12px;
    letter-spacing: 0.1em;
  }

  /* Rename input */
  .rename-input {
    background: var(--bg-primary);
    border: 1px solid var(--accent-dim);
    color: var(--text-primary);
    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    font-size: 13px;
    padding: 2px 6px;
    border-radius: 3px;
    outline: none;
    width: 100%;
  }

  /* ═══════════════════════════════════════════ */
  /* Canvas Panel                                */
  /* ═══════════════════════════════════════════ */

  /* Resize handle between chat and canvas */
  .canvas-resize-handle {
    width: 4px;
    cursor: col-resize;
    background: var(--border);
    flex-shrink: 0;
    transition: background 0.15s;
    position: relative;
    z-index: 5;
    display: none;
  }

  .canvas-resize-handle:hover,
  .canvas-resize-handle.dragging {
    background: var(--accent-dim);
  }

  .canvas-resize-handle.visible {
    display: block;
  }

  .canvas-panel {
    width: 0;
    min-width: 0;
    max-width: 0;
    background: var(--bg-secondary);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1), min-width 0.3s cubic-bezier(0.4, 0, 0.2, 1), max-width 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
    opacity: 0;
  }

  .canvas-panel.open {
    width: 50%;
    min-width: 300px;
    max-width: 70%;
    opacity: 1;
  }

  .canvas-panel.no-transition {
    transition: none;
  }

  /* Canvas Header */
  .canvas-header {
    padding: 0;
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    background: rgba(26, 30, 38, 0.6);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
  }

  .canvas-header-top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    min-height: 48px;
    gap: 8px;
  }

  .canvas-header-left {
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 0;
    flex: 1;
    overflow: hidden;
  }

  .canvas-title {
    font-size: 12px;
    font-weight: 500;
    color: var(--text-primary);
    letter-spacing: 0.02em;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    min-width: 0;
    flex-shrink: 1;
  }

  .canvas-lang-tag {
    font-family: 'Geist Mono', monospace;
    font-size: 9px;
    letter-spacing: 0.08em;
    color: var(--accent-dim);
    background: var(--accent-glow);
    padding: 2px 6px;
    border-radius: 3px;
    text-transform: uppercase;
    flex-shrink: 0;
  }

  /* Artifact selector dropdown */
  .canvas-artifact-select {
    position: relative;
    flex-shrink: 0;
  }

  .canvas-artifact-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    padding: 3px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 10px;
    font-family: 'Geist Mono', monospace;
    transition: all 0.12s;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .canvas-artifact-btn:hover {
    background: var(--bg-hover);
    color: var(--text-primary);
  }

  .canvas-artifact-dropdown {
    display: none;
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    background: rgba(30, 34, 42, 0.95);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.06);
    border-radius: 8px;
    padding: 4px;
    min-width: 200px;
    max-width: 300px;
    z-index: 100;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    animation: dropdownIn 0.12s ease-out;
    max-height: 240px;
    overflow-y: auto;
  }

  .canvas-artifact-dropdown.open {
    display: block;
  }

  .canvas-artifact-option {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    border-radius: 4px;
    cursor: pointer;
    border: none;
    background: none;
    width: 100%;
    text-align: left;
    color: var(--text-secondary);
    font-family: inherit;
    font-size: 12px;
    transition: all 0.1s;
  }

  .canvas-artifact-option:hover {
    background: var(--bg-hover);
    color: var(--text-primary);
  }

  .canvas-artifact-option.active {
    background: var(--accent-glow);
    color: var(--accent);
    border: 1px solid rgba(142, 195, 227, 0.15);
  }

  .canvas-artifact-option:not(.active) {
    border: 1px solid transparent;
  }

  .canvas-artifact-option-icon {
    font-size: 11px;
    flex-shrink: 0;
    width: 16px;
    text-align: center;
  }

  .canvas-artifact-option-title {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
  }

  .canvas-header-actions {
    display: flex;
    gap: 2px;
    flex-shrink: 0;
    margin-left: 8px;
  }

  .canvas-action-btn {
    background: none;
    border: 1px solid transparent;
    color: var(--text-tertiary);
    width: 28px;
    height: 28px;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    transition: all 0.12s;
    position: relative;
  }

  .canvas-action-btn:hover {
    background: var(--bg-hover);
    color: var(--text-primary);
    border-color: var(--border);
  }

  .canvas-action-btn.close:hover {
    color: #c44;
    border-color: rgba(204, 68, 68, 0.3);
  }

  .canvas-action-btn svg {
    width: 14px;
    height: 14px;
    stroke: currentColor;
    fill: none;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  /* Native title tooltips are used instead of CSS pseudo-elements */

  /* Tab bar */
  .canvas-tab-bar {
    display: flex;
    padding: 0 16px;
    gap: 0;
    border-top: 1px solid var(--border-subtle);
  }

  .canvas-view-tab {
    padding: 8px 14px;
    font-size: 11px;
    font-family: 'Geist Mono', monospace;
    letter-spacing: 0.05em;
    cursor: pointer;
    background: none;
    border: none;
    border-bottom: 2px solid transparent;
    color: var(--text-tertiary);
    transition: all 0.12s;
    margin-bottom: -1px;
  }

  .canvas-view-tab:hover {
    color: var(--text-secondary);
  }

  .canvas-view-tab.active {
    color: var(--accent);
    border-bottom-color: var(--accent);
  }

  /* Canvas Body */
  .canvas-body {
    flex: 1;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    position: relative;
    min-height: 0;
  }

  .canvas-body-scroll {
    flex: 1;
    overflow-y: auto;
    padding: 20px 24px;
  }

  .canvas-body-iframe {
    flex: 1;
    overflow: hidden;
    padding: 0;
  }

  /* Markdown canvas view */
  .canvas-markdown {
    font-size: 13px;
    line-height: 1.7;
    color: var(--text-primary);
  }

  .canvas-markdown h1 {
    font-size: 20px;
    font-weight: 600;
    margin: 0 0 16px;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    color: var(--text-primary);
  }

  .canvas-markdown h2 {
    font-size: 16px;
    font-weight: 600;
    margin: 24px 0 10px;
    color: var(--text-primary);
  }

  .canvas-markdown h3 {
    font-size: 14px;
    font-weight: 500;
    margin: 20px 0 8px;
    color: var(--accent);
  }

  .canvas-markdown h4 {
    font-size: 13px;
    font-weight: 500;
    margin: 16px 0 6px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .canvas-markdown p {
    margin-bottom: 12px;
  }

  .canvas-markdown p:last-child {
    margin-bottom: 0;
  }

  .canvas-markdown ul, .canvas-markdown ol {
    margin: 8px 0 12px;
    padding-left: 24px;
  }

  .canvas-markdown li {
    margin-bottom: 4px;
  }

  .canvas-markdown code {
    font-family: 'Geist Mono', monospace;
    background: rgba(255, 255, 255, 0.06);
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 12px;
  }

  .canvas-markdown pre {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    padding: 14px 16px;
    margin: 12px 0;
    overflow-x: auto;
    font-size: 12px;
    line-height: 1.5;
  }

  .canvas-markdown pre code {
    background: none;
    border: none;
    padding: 0;
  }

  .canvas-markdown strong { color: var(--text-primary); font-weight: 600; }
  .canvas-markdown em { color: var(--text-secondary); }

  .canvas-markdown blockquote {
    border-left: 3px solid var(--accent-dim);
    padding-left: 14px;
    margin: 12px 0;
    color: var(--text-secondary);
    font-style: italic;
  }

  .canvas-markdown hr {
    border: none;
    border-top: 1px solid rgba(255, 255, 255, 0.06);
    margin: 20px 0;
  }

  .canvas-markdown table {
    width: 100%;
    border-collapse: collapse;
    margin: 12px 0;
    font-size: 12px;
  }

  .canvas-markdown th {
    text-align: left;
    padding: 8px 12px;
    border-bottom: 1px solid var(--border);
    color: var(--text-primary);
    font-weight: 600;
    background: var(--bg-tertiary);
  }

  .canvas-markdown td {
    padding: 6px 12px;
    border-bottom: 1px solid var(--border-subtle);
    color: var(--text-secondary);
  }

  .canvas-markdown tr:last-child td {
    border-bottom: none;
  }

  .canvas-markdown a {
    color: var(--accent);
    text-decoration: none;
  }

  .canvas-markdown a:hover {
    text-decoration: underline;
  }

  .canvas-markdown img {
    max-width: 100%;
    border-radius: 6px;
    margin: 8px 0;
  }

  .canvas-markdown li.task-item {
    list-style: none;
    margin-left: -20px;
  }

  .canvas-markdown li.task-item input[type="checkbox"] {
    margin-right: 8px;
    accent-color: var(--accent);
  }

  /* HTML preview iframe */
  .canvas-iframe {
    width: 100%;
    height: 100%;
    border: none;
    background: #1c1c1c;
    border-radius: 0;
  }

  /* Code view in canvas */
  .canvas-code-view {
    background: #111111;
    border-radius: 6px;
    overflow: auto;
    height: 100%;
    margin: 0;
  }

  .canvas-code-view pre {
    margin: 0;
    padding: 16px;
    font-family: 'Geist Mono', monospace;
    font-size: 13px;
    line-height: 1.5;
    background: transparent !important;
    color: #c9d1d9;
    white-space: pre;
  }

  .canvas-code-view pre code {
    font-family: 'Geist Mono', monospace;
    background: none !important;
    border: none !important;
    padding: 0 !important;
    font-size: inherit;
    color: inherit;
  }

  /* Version history panel */
  .canvas-version-panel {
    display: none;
    position: absolute;
    top: 0;
    right: 0;
    width: 220px;
    height: 100%;
    background: rgba(26, 29, 35, 0.95);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border-left: 1px solid rgba(255, 255, 255, 0.06);
    z-index: 20;
    flex-direction: column;
    animation: slideInRight 0.2s ease-out;
    box-shadow: -4px 0 16px rgba(0, 0, 0, 0.3);
  }

  .canvas-version-panel.open {
    display: flex;
  }

  @keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }

  .canvas-version-header {
    padding: 12px 14px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
  }

  .canvas-version-title {
    font-size: 11px;
    font-weight: 500;
    color: var(--text-secondary);
    letter-spacing: 0.05em;
  }

  .canvas-version-close {
    background: none;
    border: none;
    color: var(--text-tertiary);
    cursor: pointer;
    font-size: 12px;
    padding: 2px 4px;
    border-radius: 3px;
    transition: color 0.12s;
  }

  .canvas-version-close:hover {
    color: var(--text-primary);
  }

  .canvas-version-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
  }

  .canvas-version-item {
    padding: 8px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 11px;
    color: var(--text-secondary);
    border: 1px solid transparent;
    transition: all 0.1s;
    margin-bottom: 4px;
  }

  .canvas-version-item:hover {
    background: var(--bg-hover);
    color: var(--text-primary);
  }

  .canvas-version-item.active {
    background: var(--accent-glow);
    color: var(--accent);
    border-color: rgba(142, 195, 227, 0.15);
  }

  .canvas-version-item-time {
    font-family: 'Geist Mono', monospace;
    font-size: 9px;
    color: var(--text-tertiary);
    margin-top: 2px;
    letter-spacing: 0.03em;
  }

  /* Canvas empty state */
  .canvas-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: var(--text-tertiary);
    gap: 10px;
  }

  .canvas-empty-icon {
    font-size: 32px;
    opacity: 0.15;
    color: var(--accent);
  }

  .canvas-empty-text {
    font-size: 11px;
    letter-spacing: 0.08em;
  }

  /* Canvas footer — version count */
  .canvas-footer {
    padding: 6px 16px;
    border-top: 1px solid var(--border-subtle);
    font-family: 'Geist Mono', monospace;
    font-size: 9px;
    color: var(--text-tertiary);
    letter-spacing: 0.05em;
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
  }

  /* Prevent text selection during resize */
  .resizing {
    user-select: none !important;
    cursor: col-resize !important;
  }

  .resizing iframe {
    pointer-events: none !important;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .sidebar { width: 220px; min-width: 220px; }
    .canvas-panel.open { width: 100%; min-width: 0; position: absolute; right: 0; z-index: 10; height: 100%; }
  }

  @media (max-width: 600px) {
    .sidebar {
      position: absolute;
      z-index: 10;
      height: 100%;
      transform: translateX(-100%);
      transition: transform 0.2s;
    }
    .sidebar.open { transform: translateX(0); }
  }

  /* ══════════════════════════════════════════════
     COMMAND CENTER — Browse panels
     ══════════════════════════════════════════════ */

  /* Sidebar navigation tabs (hidden - replaced by nav-rail) */
  .sidebar-nav {
    display: none !important;
  }
  .sidebar-nav-btn {
    flex: 1 1 0;
    min-width: 0;
    background: none;
    border: none;
    color: var(--text-tertiary);
    padding: 10px 2px 8px;
    cursor: pointer;
    font-size: 8px;
    font-family: inherit;
    letter-spacing: 0.02em;
    text-transform: uppercase;
    transition: all 0.15s;
    border-bottom: 2px solid transparent;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .sidebar-nav-btn:hover {
    color: var(--text-secondary);
    background: var(--bg-hover);
  }
  .sidebar-nav-btn.active {
    color: var(--accent);
    border-bottom-color: var(--accent);
  }
  .sidebar-nav-btn svg {
    width: 13px;
    height: 13px;
    opacity: 0.7;
    flex-shrink: 0;
  }
  .sidebar-nav-btn.active svg {
    opacity: 1;
  }
  .nav-label {
    font-size: 7.5px;
    line-height: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
  }
  /* (old collapsed sidebar-nav styles removed - nav-rail replaces them) */

  /* Browse panel (replaces thread-list when on non-chat tab) */
  .browse-panel {
    display: none;
    flex: 1;
    flex-direction: column;
    overflow: hidden;
  }
  .browse-panel.active {
    display: flex;
  }
  .browse-panel-header {
    padding: 12px 16px 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
  }
  .browse-panel-title {
    font-size: 11px;
    font-weight: 500;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--text-secondary);
  }
  .browse-panel-count {
    font-size: 11px;
    color: var(--text-tertiary);
    font-variant-numeric: tabular-nums;
  }
  .browse-search {
    margin: 0 12px 8px;
    padding: 7px 10px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 12px;
    outline: none;
    transition: border-color 0.15s;
    flex-shrink: 0;
  }
  .browse-search:focus {
    border-color: var(--accent-dim);
  }
  .browse-search::placeholder {
    color: var(--text-tertiary);
  }
  .browse-list {
    flex: 1;
    overflow-y: auto;
    padding: 0 8px 8px;
  }

  /* Browse items (generic list items used across panels) */
  .browse-item {
    padding: 10px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.12s;
    margin-bottom: 2px;
    border: 1px solid transparent;
  }
  .browse-item:hover {
    background: var(--bg-hover);
  }
  .browse-item.active {
    background: var(--bg-tertiary);
    border-color: var(--border);
  }
  .browse-item-title {
    font-size: 12px;
    font-weight: 450;
    color: var(--text-primary);
    margin-bottom: 3px;
    display: flex;
    align-items: flex-start;
    gap: 6px;
    min-width: 0;
    line-height: 1.4;
  }
  .browse-item-desc {
    font-size: 11px;
    color: var(--text-tertiary);
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  .browse-item-meta {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-top: 4px;
    font-size: 10px;
    color: var(--text-tertiary);
    min-width: 0;
    overflow: hidden;
  }
  .browse-tag {
    display: inline-flex;
    flex-shrink: 0;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 9px;
    font-weight: 500;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    line-height: 1.2;
    margin-top: 1px;
  }
  .browse-tag.builtin { background: rgba(142, 195, 227, 0.12); color: var(--accent); }
  .browse-tag.custom { background: rgba(130, 200, 130, 0.12); color: #82c882; }
  .browse-tag.clawdhub { background: rgba(130, 160, 220, 0.12); color: #82a0dc; }
  .browse-tag.node { background: rgba(130, 200, 130, 0.1); color: #6b9; }
  .browse-tag.python { background: rgba(80, 130, 200, 0.1); color: #68a; }
  .browse-tag.rust { background: rgba(200, 120, 60, 0.1); color: #c86; }
  .browse-tag.git { background: rgba(200, 100, 80, 0.1); color: #c64; }
  .browse-tag.main { background: rgba(142, 195, 227, 0.12); color: var(--accent); }
  .browse-tag.anima { background: rgba(123, 143, 176, 0.12); color: #7b8fb0; }
  .browse-tag.enabled { background: rgba(100, 200, 100, 0.12); color: #6c6; }
  .browse-tag.disabled { background: rgba(200, 100, 100, 0.12); color: #c66; }

  /* ── Journal ── */
  .journal-filters {
    display: flex;
    gap: 4px;
    padding: 6px 12px;
    flex-wrap: wrap;
  }
  .journal-filter-pill {
    padding: 3px 10px;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--text-secondary);
    font-size: 11px;
    cursor: pointer;
    transition: all 0.15s;
    font-family: inherit;
  }
  .journal-filter-pill:hover {
    border-color: var(--accent);
    color: var(--text-primary);
  }
  .journal-filter-pill.active {
    background: var(--accent);
    border-color: var(--accent);
    color: #0a0a0a;
  }
  .journal-sort {
    display: flex;
    gap: 4px;
    padding: 2px 12px 6px;
  }
  .journal-sort-btn {
    padding: 2px 8px;
    border: none;
    background: transparent;
    color: var(--text-tertiary);
    font-size: 10px;
    cursor: pointer;
    font-family: inherit;
  }
  .journal-sort-btn.active {
    color: var(--accent);
  }
  .journal-sort-btn:hover {
    color: var(--text-primary);
  }
  .journal-load-more {
    padding: 10px 16px;
    text-align: center;
    color: var(--accent);
    font-size: 12px;
    cursor: pointer;
    border-top: 1px solid var(--border);
  }
  .journal-load-more:hover {
    background: rgba(142, 195, 227, 0.05);
  }
  .journal-stats {
    display: flex;
    gap: 12px;
    padding: 4px 16px 8px;
    flex-shrink: 0;
    flex-wrap: wrap;
  }
  .journal-stat {
    font-size: 11px;
    color: var(--text-tertiary);
  }
  .journal-stat strong {
    color: #7b8fb0;
    font-weight: 600;
  }
  .journal-updated {
    font-size: 10px;
    color: var(--text-tertiary);
    padding: 0 16px 6px;
    opacity: 0.7;
  }
  .journal-section-header {
    font-size: 10px;
    color: var(--text-tertiary);
    padding: 14px 12px 6px;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    font-weight: 500;
  }
  /* Journal sidebar list items (compact, like thread-item) */
  .journal-item {
    padding: 10px 16px;
    cursor: pointer;
    transition: background 0.15s;
    border-bottom: 1px solid var(--border-subtle);
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .journal-item:hover {
    background: var(--bg-hover);
  }
  .journal-item.active {
    background: rgba(142, 195, 227, 0.08);
  }
  .journal-item-preview {
    font-size: 12px;
    color: var(--text-primary);
    line-height: 1.4;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
  }
  .journal-item-meta {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .journal-item-time {
    font-size: 10px;
    color: var(--text-tertiary);
  }
  /* Detail view journal entry styling */
  .journal-detail-content {
    font-size: 14px;
    color: var(--text-primary);
    line-height: 1.7;
    white-space: pre-wrap;
    padding: 4px 0;
  }
  .journal-detail-meta {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid var(--border);
  }
  .journal-detail-tags {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    margin-top: 8px;
  }
  .journal-badge {
    font-size: 9px;
    padding: 1px 6px;
    border-radius: 3px;
    font-weight: 500;
    letter-spacing: 0.03em;
  }
  .journal-badge.background { background: rgba(123, 143, 176, 0.12); color: #7b8fb0; }
  .journal-badge.reflection { background: rgba(142, 195, 227, 0.12); color: var(--accent); }
  .journal-badge.question { background: rgba(200, 170, 100, 0.12); color: #c8a864; }
  .journal-badge.dream { background: rgba(160, 130, 200, 0.12); color: #a082c8; }
  .journal-badge.published { background: rgba(100, 200, 140, 0.12); color: #64c88c; }
  .journal-badge.soften { background: rgba(200, 170, 100, 0.1); color: #b09860; }
  .journal-badge.deep_soften { background: rgba(200, 130, 80, 0.1); color: #c08050; }
  .journal-badge.archive { background: rgba(200, 100, 100, 0.1); color: #c06060; }
  .journal-tag {
    font-size: 9px;
    padding: 1px 5px;
    border-radius: 3px;
    background: rgba(123, 143, 176, 0.08);
    color: #556b8a;
  }
  /* Journal detail - dream styling */
  .journal-detail-dream {
    background: linear-gradient(135deg, rgba(160, 130, 200, 0.06), rgba(100, 130, 200, 0.04));
    padding: 20px;
    border-radius: 8px;
    border-left: 3px solid rgba(160, 130, 200, 0.4);
  }
  .journal-detail-dream .journal-detail-content {
    font-style: italic;
    color: rgba(200, 185, 230, 0.9);
  }
  /* Published link in detail */
  .journal-detail-tweet-link {
    color: var(--accent);
    text-decoration: none;
    font-size: 13px;
  }
  .journal-detail-tweet-link:hover {
    text-decoration: underline;
  }
  /* Decay detail */
  .journal-sharpness {
    font-size: 12px;
    color: var(--text-secondary);
    font-variant-numeric: tabular-nums;
  }
  .journal-sharpness .arrow {
    color: #c06060;
    margin: 0 4px;
  }

  /* History items */
  .history-date-header {
    font-size: 10px;
    color: var(--text-tertiary);
    padding: 14px 12px 6px;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    font-weight: 500;
  }
  .history-item {
    padding: 10px 12px;
    display: flex;
    flex-direction: column;
    gap: 0;
  }
  .history-item-top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
    position: relative;
    z-index: 1;
  }
  .history-time {
    font-size: 10px;
    color: var(--text-tertiary);
    font-variant-numeric: tabular-nums;
  }
  .history-preview {
    font-size: 11.5px;
    color: var(--text-primary);
    opacity: 0.75;
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    margin-bottom: 5px;
    word-break: break-word;
  }
  .history-meta {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 10px;
    color: var(--text-tertiary);
  }
  .history-meta span {
    white-space: nowrap;
  }

  /* Detail view (inside main area, replaces messages when active) */
  .detail-view {
    display: none;
    flex-direction: column;
    flex: 1;
    overflow-y: auto;
  }
  .detail-view.active {
    display: flex;
  }
  .detail-content {
    flex: 1;
    overflow-y: auto;
    padding: 20px 24px;
  }
  .detail-content pre {
    background: rgba(0,0,0,0.3);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
    overflow-x: auto;
    font-size: 12px;
    line-height: 1.6;
    color: var(--text-secondary);
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  .detail-content h1, .detail-content h2, .detail-content h3 {
    color: var(--text-primary);
    margin: 20px 0 8px;
    font-weight: 500;
  }
  .detail-content h1 { font-size: 20px; }
  .detail-content h2 { font-size: 16px; }
  .detail-content h3 { font-size: 14px; }
  .detail-content p {
    color: var(--text-secondary);
    line-height: 1.7;
    margin-bottom: 12px;
    font-size: 13px;
  }
  .detail-section {
    margin-bottom: 24px;
  }
  .detail-section-title {
    font-size: 11px;
    font-weight: 500;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--text-tertiary);
    margin-bottom: 12px;
    padding-bottom: 6px;
    border-bottom: 1px solid var(--border-subtle);
  }

  /* Cron job cards */
  .cron-card {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px 16px;
    margin-bottom: 8px;
  }
  .cron-card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
  }
  .cron-card-name {
    font-size: 13px;
    font-weight: 500;
    color: var(--text-primary);
  }
  .cron-card-detail {
    font-size: 11px;
    color: var(--text-tertiary);
    line-height: 1.6;
  }
  .cron-card-detail span {
    color: var(--text-secondary);
  }

  /* Session transcript in detail */
  .transcript-msg {
    padding: 12px 0;
    border-bottom: 1px solid var(--border-subtle);
  }
  .transcript-msg:last-child { border-bottom: none; }
  .transcript-msg-role {
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    margin-bottom: 4px;
  }
  .transcript-msg-role.user { color: var(--text-secondary); }
  .transcript-msg-role.assistant { color: var(--accent); }
  .transcript-msg-content {
    font-size: 13px;
    color: var(--text-secondary);
    line-height: 1.6;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  .transcript-msg-meta {
    font-size: 10px;
    color: var(--text-tertiary);
    margin-top: 6px;
  }

  /* System status cards */
  .status-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 12px;
    margin-bottom: 24px;
  }
  .status-card {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px 16px;
  }
  .status-card-label {
    font-size: 10px;
    font-weight: 500;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--text-tertiary);
    margin-bottom: 6px;
  }
  .status-card-value {
    font-size: 20px;
    font-weight: 300;
    color: var(--text-primary);
    font-variant-numeric: tabular-nums;
  }
  .status-card-sub {
    font-size: 11px;
    color: var(--text-tertiary);
    margin-top: 4px;
  }

  /* Agent filter tabs */
  .filter-tabs {
    display: flex;
    gap: 4px;
    padding: 0 12px 6px;
    flex-shrink: 0;
  }
  .filter-tab {
    padding: 4px 10px;
    border-radius: 4px;
    border: 1px solid var(--border);
    background: none;
    color: var(--text-tertiary);
    font-size: 10px;
    font-family: inherit;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.12s;
  }
  .filter-tab:hover { background: var(--bg-hover); color: var(--text-secondary); }
  .filter-tab.active {
    background: var(--accent-glow);
    border-color: var(--accent-dim);
    color: var(--accent);
  }

  /* Memory type badges */
  .memory-type-badge {
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    margin-right: 6px;
    flex-shrink: 0;
  }
  .memory-type-badge.core { background: var(--accent); }
  .memory-type-badge.daily { background: #6b9; }
  .memory-type-badge.context { background: #68a; }
  .memory-type-badge.document { background: #98a; }
  .memory-type-badge.data { background: #a86; }
  .memory-type-badge.genome { background: #c86; }
  .memory-type-badge.other { background: var(--text-tertiary); }
</style>
</head>
<body>

<div class="app" id="app">

  <!-- ═══ NAV RAIL ═══ -->
  <div class="nav-rail">
    <div class="nav-rail-top">
      <button class="nav-rail-logo" onclick="switchSection('home')" title="Home">⏀</button>

      <button class="nav-rail-btn active" data-section="chat" data-tooltip="Chat" onclick="switchSection('chat')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/></svg>
      </button>

      <div class="nav-rail-divider"></div>

      <button class="nav-rail-btn" data-section="skills" data-tooltip="Skills" onclick="switchSection('skills')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 000 1.4l1.6 1.6a1 1 0 001.4 0l3.77-3.77a6 6 0 01-7.94 7.94l-6.91 6.91a2.12 2.12 0 01-3-3l6.91-6.91a6 6 0 017.94-7.94l-3.76 3.76z"/></svg>
      </button>
      <button class="nav-rail-btn" data-section="history" data-tooltip="Session Log" onclick="switchSection('history')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
      </button>
      <button class="nav-rail-btn" data-section="cron" data-tooltip="Tasks" onclick="switchSection('cron')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
      </button>
      <button class="nav-rail-btn" data-section="projects" data-tooltip="Files" onclick="switchSection('projects')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
      </button>
      <button class="nav-rail-btn" data-section="memory" data-tooltip="Memory" onclick="switchSection('memory')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a4 4 0 014 4c0 1.95-1.4 3.58-3.25 3.93L12 22l-.75-12.07A4.001 4.001 0 0112 2z"/><circle cx="12" cy="6" r="1"/></svg>
      </button>
      <button class="nav-rail-btn" data-section="journal" data-tooltip="Journal" onclick="switchSection('journal')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 016.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 014 19.5v-15A2.5 2.5 0 016.5 2z"/><line x1="8" y1="7" x2="16" y2="7"/><line x1="8" y1="11" x2="13" y2="11"/></svg>
      </button>
    </div>

    <div class="nav-rail-bottom">
      <button class="nav-rail-btn" data-tooltip="Notifications" onclick="toggleNotificationPanel(event)" style="position:relative" id="notifBell">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8A6 6 0 006 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 01-3.46 0"/></svg>
        <span class="nav-rail-notification-dot" id="navRailNotifDot" style="display:none;"></span>
      </button>
      <div class="nav-rail-avatar" id="navRailAvatar" onclick="toggleAgentSelector(event)" title="Switch Agent">⏀</div>
      <button class="nav-rail-btn" data-tooltip="Toggle Sidebar" onclick="toggleSidebarCollapse()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="9" y1="3" x2="9" y2="21"/></svg>
      </button>
    </div>
  </div>

  <!-- ═══ SIDEBAR ═══ -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title" id="agentSelector" onclick="toggleAgentSelector(event)">
        <span class="agent-selector-glyph" id="agentSelectorGlyph">⏀</span>
        <span class="title-text" id="agentSelectorName">VEKTOR</span>
        <span class="agent-selector-chevron title-text">▾</span>
        <div class="agent-selector-dropdown" id="agentSelectorDropdown">
          <button class="agent-selector-option active" data-agent="main" onclick="switchAgent('main', event)">
            <span class="as-glyph" style="color:#8EC3E3">⏀</span>
            <span>VEKTOR</span>
            <span class="as-check">✓</span>
          </button>
          <button class="agent-selector-option" data-agent="anima" onclick="switchAgent('anima', event)">
            <span class="as-glyph" style="color:#7b8fb0">△</span>
            <span>ANIMA</span>
            <span class="as-check">✓</span>
          </button>
        </div>
      </div>
      <div class="new-thread-container">
        <button class="new-thread-btn" onclick="toggleNewThreadDropdown(event)" title="New thread">+</button>
        <div class="new-thread-dropdown" id="newThreadDropdown">
          <button class="new-thread-option" onclick="createThread(); closeNewThreadDropdown();">
            <span class="option-glyph amber">⏀</span>
            <div>
              <div class="option-label">Chat with Vektor</div>
              <div class="option-desc">Direct conversation with Vektor</div>
            </div>
          </button>
          <button class="new-thread-option" onclick="createThread(null, 'anima'); closeNewThreadDropdown();">
            <span class="option-glyph blue-slate">△</span>
            <div>
              <div class="option-label">Chat with Anima</div>
              <div class="option-desc">Direct conversation with Anima</div>
            </div>
          </button>
          <button class="new-thread-option" onclick="createGroupThread(); closeNewThreadDropdown();">
            <span class="option-glyph dual">⏀ △</span>
            <div>
              <div class="option-label">Group Chat</div>
              <div class="option-desc">Vektor + Anima together</div>
            </div>
          </button>
        </div>
      </div>
    </div>
    <!-- Navigation Tabs -->
    <div class="sidebar-nav" id="sidebarNav">
      <button class="sidebar-nav-btn active" data-panel="chat" onclick="switchPanel('chat')" title="Conversations">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/></svg>
        <span class="nav-label">Chat</span>
      </button>
      <button class="sidebar-nav-btn" data-panel="skills" onclick="switchPanel('skills')" title="Skills">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 000 1.4l1.6 1.6a1 1 0 001.4 0l3.77-3.77a6 6 0 01-7.94 7.94l-6.91 6.91a2.12 2.12 0 01-3-3l6.91-6.91a6 6 0 017.94-7.94l-3.76 3.76z"/></svg>
        <span class="nav-label">Skills</span>
      </button>
      <button class="sidebar-nav-btn" data-panel="history" onclick="switchPanel('history')" title="Session History">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
        <span class="nav-label">Log</span>
      </button>
      <button class="sidebar-nav-btn" data-panel="cron" onclick="switchPanel('cron')" title="Scheduled Tasks">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
        <span class="nav-label">Tasks</span>
      </button>
      <button class="sidebar-nav-btn" data-panel="projects" onclick="switchPanel('projects')" title="Projects">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
        <span class="nav-label">Files</span>
      </button>
      <button class="sidebar-nav-btn" data-panel="memory" onclick="switchPanel('memory')" title="Memory">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a4 4 0 014 4c0 1.95-1.4 3.58-3.25 3.93L12 22l-.75-12.07A4.001 4.001 0 0112 2z"/><circle cx="12" cy="6" r="1"/></svg>
        <span class="nav-label">Mem</span>
      </button>
      <button class="sidebar-nav-btn" data-panel="journal" onclick="switchPanel('journal')" title="Anima's Journal">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 016.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 014 19.5v-15A2.5 2.5 0 016.5 2z"/><line x1="8" y1="7" x2="16" y2="7"/><line x1="8" y1="11" x2="13" y2="11"/></svg>
        <span class="nav-label">Journal</span>
      </button>
    </div>

    <!-- Chat thread list (default) -->
    <div class="thread-list" id="threadList"></div>

    <!-- Skills browse panel -->
    <div class="browse-panel" id="panelSkills">
      <div class="browse-panel-header">
        <span class="browse-panel-title">Skills</span>
        <span class="browse-panel-count" id="skillsCount">—</span>
      </div>
      <input class="browse-search" id="skillsSearch" placeholder="Search skills..." oninput="filterSkills()">
      <div class="browse-list" id="skillsList"></div>
    </div>

    <!-- History browse panel -->
    <div class="browse-panel" id="panelHistory">
      <div class="browse-panel-header">
        <span class="browse-panel-title">Sessions</span>
        <span class="browse-panel-count" id="historyCount">—</span>
      </div>
      <div class="filter-tabs" id="historyAgentFilter"></div>
      <input class="browse-search" id="historySearch" placeholder="Search conversations..." oninput="filterHistory()">
      <div class="browse-list" id="historyList"></div>
    </div>

    <!-- Cron browse panel -->
    <div class="browse-panel" id="panelCron">
      <div class="browse-panel-header">
        <span class="browse-panel-title">Scheduled Tasks</span>
        <span class="browse-panel-count" id="cronCount">—</span>
      </div>
      <div class="browse-list" id="cronList"></div>
    </div>

    <!-- Projects browse panel -->
    <div class="browse-panel" id="panelProjects">
      <div class="browse-panel-header">
        <span class="browse-panel-title">Projects</span>
        <span class="browse-panel-count" id="projectsCount">—</span>
      </div>
      <input class="browse-search" id="projectsSearch" placeholder="Search projects..." oninput="filterProjects()">
      <div class="browse-list" id="projectsList"></div>
    </div>

    <!-- Memory browse panel -->
    <div class="browse-panel" id="panelMemory">
      <div class="browse-panel-header">
        <span class="browse-panel-title">Memory</span>
        <span class="browse-panel-count" id="memoryCount">—</span>
      </div>
      <div class="browse-list" id="memoryList"></div>
    </div>

    <!-- Journal browse panel -->
    <div class="browse-panel" id="panelJournal">
      <div class="browse-panel-header">
        <span class="browse-panel-title">Anima's Journal</span>
        <span class="browse-panel-count" id="journalCount">—</span>
      </div>
      <div class="journal-stats" id="journalStats"></div>
      <div class="journal-filters" id="journalFilters">
        <button class="journal-filter-pill active" data-filter="all" onclick="filterJournal('all')">All</button>
        <button class="journal-filter-pill" data-filter="thought" onclick="filterJournal('thought')">Thoughts</button>
        <button class="journal-filter-pill" data-filter="dream" onclick="filterJournal('dream')">Dreams</button>
        <button class="journal-filter-pill" data-filter="published" onclick="filterJournal('published')">Published</button>
        <button class="journal-filter-pill" data-filter="decay" onclick="filterJournal('decay')">Decay</button>
      </div>
      <div class="journal-sort" id="journalSort">
        <button class="journal-sort-btn active" data-sort="recent" onclick="sortJournal('recent')">Recent</button>
        <button class="journal-sort-btn" data-sort="salience" onclick="sortJournal('salience')">Salience</button>
      </div>
      <div class="browse-list" id="journalList"></div>
      <div class="journal-load-more" id="journalLoadMore" style="display:none" onclick="loadMoreJournal()">Load more…</div>
    </div>

    <div class="sidebar-footer">
      <span class="status-dot"></span>
      <span class="footer-text">OPUS 4.6 · GATEWAY</span>
    </div>
  </div>

  <!-- Main -->
  <div class="main">
    <div class="main-header">
      <div class="breadcrumb" id="breadcrumb">
        <span class="breadcrumb-current">Chat</span>
      </div>
      <span class="main-header-glyph" id="mainHeaderGlyph">⏀</span>
    </div>

    <!-- Dashboard / Home view -->
    <div class="dashboard-view" id="dashboardView" style="display:none;">
      <div class="dashboard-inner fade-in">
        <div class="dashboard-welcome">
          <div class="dashboard-glyph">⏀</div>
          <div class="dashboard-title">Welcome back</div>
          <div class="dashboard-subtitle">What would you like to work on?</div>
        </div>
        <div class="dashboard-stats" id="dashboardStats">
          <div class="stat-card" onclick="switchSection('chat')">
            <div class="stat-number" id="statThreads">—</div>
            <div class="stat-label">Threads</div>
          </div>
          <div class="stat-card" onclick="switchSection('skills')">
            <div class="stat-number" id="statSkills">—</div>
            <div class="stat-label">Skills</div>
          </div>
          <div class="stat-card" onclick="switchSection('memory')">
            <div class="stat-number" id="statMemory">—</div>
            <div class="stat-label">Memories</div>
          </div>
        </div>
        <div class="dashboard-section-title">Quick Actions</div>
        <div class="dashboard-recent">
          <div class="recent-item" onclick="createThread()">
            <span class="recent-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/></svg></span>
            <span class="recent-text">New conversation</span>
          </div>
          <div class="recent-item" onclick="switchSection('skills')">
            <span class="recent-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 000 1.4l1.6 1.6a1 1 0 001.4 0l3.77-3.77a6 6 0 01-7.94 7.94l-6.91 6.91a2.12 2.12 0 01-3-3l6.91-6.91a6 6 0 017.94-7.94l-3.76 3.76z"/></svg></span>
            <span class="recent-text">Browse skills</span>
          </div>
          <div class="recent-item" onclick="switchSection('journal')">
            <span class="recent-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 016.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 014 19.5v-15A2.5 2.5 0 016.5 2z"/></svg></span>
            <span class="recent-text">View journal</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Agent conversation tabs -->
    <div class="agent-tabs" id="agentTabs"></div>

    <div class="messages" id="messages">
      <div class="empty-state">
        <div class="empty-glyph">⏀</div>
        <div class="empty-text">START A CONVERSATION</div>
      </div>
    </div>
    <div class="input-area">
      <div class="attachment-preview" id="attachmentPreview"></div>
      <div class="typing-indicator" id="typingIndicator">
        <div class="typing-dots"><span></span><span></span><span></span></div>
        <span id="typingLabel">thinking...</span>
      </div>
      <div class="context-health-bar" id="contextHealthBar" style="display:none;">
        <span class="context-health-dot" id="contextHealthDot">⬤</span>
        <span class="context-health-text" id="contextHealthText">0% context</span>
      </div>
      <div class="input-wrapper">
        <button class="upload-btn" onclick="document.getElementById('fileInput').click()" title="Upload file or image">
          <svg viewBox="0 0 24 24"><path d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.48"/></svg>
        </button>
        <textarea
          class="input-box"
          id="inputBox"
          placeholder="Message Vektor..."
          rows="1"
          onkeydown="handleKey(event)"
          oninput="autoResize(this); updateCharCount(); saveDraft();"
        ></textarea>
        <span class="char-count" id="charCount">0</span>
        <button class="send-btn" id="sendBtn" onclick="handleSendClick()" disabled>↑</button>
      </div>
      <input type="file" id="fileInput" multiple accept="image/*,.txt,.md,.html,.csv,.json,.pdf" style="display:none" onchange="handleFileSelect(event)">
    </div>

    <!-- Drop overlay -->
    <div class="drop-overlay" id="dropOverlay">
      <div class="drop-overlay-icon">⏀</div>
      <div class="drop-overlay-text">DROP FILES HERE</div>
    </div>

    <!-- Lightbox for image zoom -->
    <div class="lightbox" id="lightbox">
      <div class="lightbox-toolbar">
        <button class="lightbox-btn" onclick="downloadLightboxImage(event)" title="Download">
          <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
        </button>
        <button class="lightbox-btn" onclick="closeLightbox(event)" title="Close (Esc)">
          <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
        </button>
      </div>
      <img id="lightboxImg" src="" alt="" onclick="event.stopPropagation()">
      <div class="lightbox-counter" id="lightboxCounter" style="display:none"></div>
    </div>

    <!-- Detail View (inside main, replaces messages when active) -->
    <div class="detail-view" id="detailView">
      <div class="detail-content" id="detailContent"></div>
    </div>
  </div>

  <!-- Resize Handle -->
  <div class="canvas-resize-handle" id="canvasResizeHandle"></div>

  <!-- Canvas Panel -->
  <div class="canvas-panel" id="canvasPanel">
    <div class="canvas-header">
      <div class="canvas-header-top">
        <div class="canvas-header-left">
          <div class="canvas-artifact-select" id="canvasArtifactSelect">
            <button class="canvas-artifact-btn" id="canvasArtifactBtn" onclick="toggleArtifactDropdown(event)">
              <span id="canvasArtifactCount">1</span> artifact<span id="canvasArtifactPlural">s</span> ▾
            </button>
            <div class="canvas-artifact-dropdown" id="canvasArtifactDropdown"></div>
          </div>
          <div class="canvas-title" id="canvasTitle">Untitled</div>
          <span class="canvas-lang-tag" id="canvasLangTag">HTML</span>
        </div>
        <div class="canvas-header-actions">
          <button class="canvas-action-btn" onclick="copyCanvasContent()" title="Copy">
            <svg viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
          </button>
          <button class="canvas-action-btn" onclick="downloadCanvasContent()" title="Download">
            <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
          </button>
          <button class="canvas-action-btn" onclick="openCanvasInNewTab()" title="Open in tab">
            <svg viewBox="0 0 24 24"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>
          </button>
          <button class="canvas-action-btn" onclick="toggleVersionHistory()" title="History" id="canvasHistoryBtn">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
          </button>
          <button class="canvas-action-btn close" onclick="closeCanvas()" title="Close">
            <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
          </button>
        </div>
      </div>
      <div class="canvas-tab-bar">
        <button class="canvas-view-tab active" id="canvasTabPreview" onclick="switchCanvasTab('preview')">Preview</button>
        <button class="canvas-view-tab" id="canvasTabCode" onclick="switchCanvasTab('code')">Code</button>
      </div>
    </div>
    <div class="canvas-body" id="canvasBody">
      <div class="canvas-empty">
        <div class="canvas-empty-icon">◫</div>
        <div class="canvas-empty-text">NO ARTIFACTS</div>
      </div>
      <!-- Version history side panel -->
      <div class="canvas-version-panel" id="canvasVersionPanel">
        <div class="canvas-version-header">
          <span class="canvas-version-title">VERSION HISTORY</span>
          <button class="canvas-version-close" onclick="toggleVersionHistory()">✕</button>
        </div>
        <div class="canvas-version-list" id="canvasVersionList"></div>
      </div>
    </div>
    <div class="canvas-footer" id="canvasFooter">
      <span id="canvasFooterInfo">Ready</span>
      <span id="canvasVersionCount"></span>
    </div>
  </div>
</div>

<!-- Toast container -->
<div class="toast-container" id="toastContainer"></div>

<script>
// ══════════════════════════════════════════════
// ── Config ──
// ══════════════════════════════════════════════
const GATEWAY_URL = '/v1/responses';
const GATEWAY_URL_LEGACY = '/v1/chat/completions';
const GATEWAY_TOKEN = '4eb4da3535e77ff6852b1b97e69d0e0965205018e8012ff1';
const AGENT_ID = 'main';
const STORAGE_KEY = 'vektor_threads';
const DRAFT_STORAGE_KEY = 'vektor_drafts';

const IMAGE_MIMES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
const FILE_MIMES = ['text/plain', 'text/markdown', 'text/html', 'text/csv', 'application/json', 'application/pdf'];
const MAX_IMAGE_BYTES = 10 * 1024 * 1024;
const MAX_FILE_BYTES = 5 * 1024 * 1024;

// ═══════════════════════════════════════════
// Agent Registry (Group Chat)
// ═══════════════════════════════════════════
const AGENTS = {
  main: {
    id: 'main',
    name: 'VEKTOR',
    glyph: '⏀',
    accent: '#8EC3E3',
    accentDim: '#6A9DBD',
    accentGlow: 'rgba(142, 195, 227, 0.08)'
  },
  anima: {
    id: 'anima',
    name: 'ANIMA',
    glyph: '△',
    accent: '#7b8fb0',
    accentDim: '#556b8a',
    accentGlow: 'rgba(123, 143, 176, 0.08)'
  }
};

// ══════════════════════════════════════════════
// ── Global Agent Selection ──
// ══════════════════════════════════════════════
let selectedAgentId = localStorage.getItem('vektor-selected-agent') || 'main';

// Agent tab state — stores last active thread per agent
let agentLastThread = JSON.parse(localStorage.getItem('vektor-agent-last-thread') || '{}');
function saveAgentLastThread() {
  localStorage.setItem('vektor-agent-last-thread', JSON.stringify(agentLastThread));
}

function toggleAgentSelector(e) {
  e.stopPropagation();
  const dropdown = document.getElementById('agentSelectorDropdown');
  const selector = document.getElementById('agentSelector');
  const isOpen = dropdown.classList.contains('open');
  dropdown.classList.toggle('open', !isOpen);
  selector.classList.toggle('open', !isOpen);
  if (!isOpen) {
    // Position dropdown below the selector using fixed positioning
    const rect = selector.getBoundingClientRect();
    dropdown.style.top = (rect.bottom + 6) + 'px';
    dropdown.style.left = rect.left + 'px';
    // Close on next outside click
    setTimeout(() => {
      document.addEventListener('click', closeAgentSelector, { once: true });
    }, 0);
  }
}

function closeAgentSelector() {
  document.getElementById('agentSelectorDropdown').classList.remove('open');
  document.getElementById('agentSelector').classList.remove('open');
}

function switchAgent(agentId, e) {
  if (e) e.stopPropagation();
  if (agentId === selectedAgentId) {
    closeAgentSelector();
    return;
  }
  selectedAgentId = agentId;
  localStorage.setItem('vektor-selected-agent', agentId);
  applyAgentTheme(agentId);

  // Invalidate agent-specific caches
  ccCache.skills = null;
  ccCache.memory = null;
  ccCache.projects = null;
  ccCache.history = null;
  ccCache.journal = null;

  // Reload current panel if it's agent-specific
  if (['skills', 'memory', 'projects', 'history', 'journal'].includes(currentPanel)) {
    loadPanelData(currentPanel);
  }

  // Re-render thread list (filtered)
  renderThreadList();

  // If active thread doesn't belong to this agent (and isn't group), switch to remembered or first matching
  const activeThread = threads.find(t => t.id === activeThreadId);
  if (!activeThread || (activeThread.mode !== 'group' && activeThread.agentId !== agentId)) {
    const remembered = agentLastThread[agentId];
    const rememberedThread = remembered ? threads.find(t => t.id === remembered) : null;
    const targetThread = rememberedThread || threads.find(t => t.agentId === agentId || t.mode === 'group');
    if (targetThread) {
      switchThread(targetThread.id);
    } else {
      // No threads for this agent — show empty state
      activeThreadId = null;
      const agent = AGENTS[agentId] || AGENTS.main;
      updateBreadcrumb([agent.name]);
      document.getElementById('inputBox').placeholder = `Message ${agent.name.charAt(0) + agent.name.slice(1).toLowerCase()}...`;
      document.getElementById('messages').innerHTML = `
        <div class="empty-state">
          <div class="empty-glyph" style="color:${agent.accent}">${agent.glyph}</div>
          <div class="empty-text">START A CONVERSATION WITH ${agent.name}</div>
        </div>`;
    }
  }

  renderAgentTabs();

  // Update nav-rail avatar
  const navAvatar = document.getElementById('navRailAvatar');
  if (navAvatar) {
    const agentInfo = AGENTS[agentId] || AGENTS.main;
    navAvatar.textContent = agentInfo.glyph;
    navAvatar.style.color = agentInfo.accent;
    navAvatar.style.borderColor = agentInfo.accentDim;
  }

  closeAgentSelector();
}

function applyAgentTheme(agentId) {
  const agent = AGENTS[agentId] || AGENTS.main;
  const root = document.documentElement;

  // Update CSS variables
  root.style.setProperty('--accent', agent.accent);
  root.style.setProperty('--accent-dim', agent.accentDim);
  root.style.setProperty('--accent-glow', agent.accentGlow);

  // Update sidebar selector UI
  document.getElementById('agentSelectorGlyph').textContent = agent.glyph;
  document.getElementById('agentSelectorName').textContent = agent.name;

  // Update dropdown active states
  document.querySelectorAll('.agent-selector-option').forEach(opt => {
    opt.classList.toggle('active', opt.dataset.agent === agentId);
  });

  // Update main header glyph
  const mainGlyph = document.querySelector('.main-header-glyph');
  if (mainGlyph) mainGlyph.textContent = agent.glyph;

  // Update empty state glyph and text
  const emptyGlyph = document.querySelector('.empty-glyph');
  if (emptyGlyph) {
    emptyGlyph.textContent = agent.glyph;
    emptyGlyph.style.color = agent.accent;
  }
  const emptyText = document.querySelector('.empty-text');
  if (emptyText) emptyText.textContent = `START A CONVERSATION WITH ${agent.name}`;

  // Update document title
  document.title = `⏀ ${agent.name}`;

  // Update drop overlay glyph
  const dropGlyph = document.querySelector('.drop-overlay-icon');
  if (dropGlyph) dropGlyph.textContent = agent.glyph;

  renderAgentTabs();
}

// ══════════════════════════════════════════════
// ── State ──
// ══════════════════════════════════════════════
let threads = [];
let activeThreadId = null;
let isStreaming = false;
let activeGroupStreams = 0;
let pendingAttachments = [];
let currentAbortController = null; // For stop generation

// ══════════════════════════════════════════════
// ── Toast Notifications ──
// ══════════════════════════════════════════════
function showToast(message) {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  container.appendChild(toast);
  setTimeout(() => toast.remove(), 2200);
}

// ══════════════════════════════════════════════
// ── Init ──
// ══════════════════════════════════════════════
async function init() {
  applyAgentTheme(selectedAgentId);
  loadThreads();
  // Migrate legacy threads that lack mode/participants/agentId
  threads.forEach(t => {
    if (!t.mode) { t.mode = 'direct'; }
    if (!t.participants) { t.participants = ['main']; }
    // Migrate: direct threads without agentId default to 'main'
    if (t.mode === 'direct' && !t.agentId) { t.agentId = 'main'; }
    // Migrate: add timestamps to existing messages
    t.messages.forEach(m => {
      if (!m.timestamp) m.timestamp = t.created || Date.now();
    });
  });
  // Auto-cleanup: remove empty threads (fix for phantom thread bug)
  const beforeCount = threads.length;
  threads = threads.filter(t => t.messages && t.messages.length > 0);
  if (threads.length !== beforeCount) {
    console.log(`[Cleanup] Removed ${beforeCount - threads.length} empty threads`);
    localStorage.setItem('vektor_threads', JSON.stringify(threads));
  }
  if (threads.length === 0) createThread('General');
  renderThreadList();
  switchThread(threads[0].id);
  initCrossTabSync();

  // Server thread loading disabled — using localStorage only for now
  // loadThreadsFromServer().then(loaded => {
  //   if (loaded) {
  //     renderThreadList();
  //     if (activeThreadId && threads.find(t => t.id === activeThreadId)) {
  //       renderMessages();
  //     }
  //   }
  // });

  // Connect WebSocket for real-time updates
  initWebSocket();
  
  const inputBox = document.getElementById('inputBox');
  inputBox.addEventListener('input', updateSendBtn);

  // Paste handler for images
  inputBox.addEventListener('paste', handlePaste);

  // Drag & drop
  let dragCounter = 0;
  document.addEventListener('dragenter', (e) => {
    e.preventDefault();
    dragCounter++;
    document.getElementById('dropOverlay').classList.add('active');
  });
  document.addEventListener('dragleave', (e) => {
    e.preventDefault();
    dragCounter--;
    if (dragCounter <= 0) {
      dragCounter = 0;
      document.getElementById('dropOverlay').classList.remove('active');
    }
  });
  document.addEventListener('dragover', (e) => e.preventDefault());
  document.addEventListener('drop', (e) => {
    e.preventDefault();
    dragCounter = 0;
    document.getElementById('dropOverlay').classList.remove('active');
    if (e.dataTransfer.files.length) handleFiles(e.dataTransfer.files);
  });

  // Close dropdown on outside click
  document.addEventListener('click', (e) => {
    const dropdown = document.getElementById('newThreadDropdown');
    const btn = e.target.closest('.new-thread-btn');
    if (!btn && dropdown.classList.contains('open')) {
      closeNewThreadDropdown();
    }
  });
}

function updateSendBtn() {
  const hasText = document.getElementById('inputBox').value.trim().length > 0;
  const hasAttachments = pendingAttachments.length > 0;
  const sendBtn = document.getElementById('sendBtn');
  // Don't change button state if we're streaming (stop btn is showing)
  if (isStreaming) return;
  sendBtn.disabled = !(hasText || hasAttachments);
}

// ═══════════════════════════════════════════
// New Thread Dropdown
// ═══════════════════════════════════════════
function toggleNewThreadDropdown(e) {
  e.stopPropagation();
  const dropdown = document.getElementById('newThreadDropdown');
  dropdown.classList.toggle('open');
}

function closeNewThreadDropdown() {
  document.getElementById('newThreadDropdown').classList.remove('open');
}

// ══════════════════════════════════════════════
// ── Storage (Local + Server Sync) ──
// ══════════════════════════════════════════════
function loadThreads() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    threads = raw ? JSON.parse(raw) : [];
  } catch { threads = []; }
}

window.addEventListener('beforeunload', () => {
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(threads)); } catch {}
});

// Archive debouncing state
let _archiveTimer = null;
const ARCHIVE_DEBOUNCE_MS = 30000; // 30 seconds

function saveThreads() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(threads));
  if (_syncChannel) {
    try { _syncChannel.postMessage({ type: 'threads-updated', activeThreadId }); } catch {}
  }
  // Server thread sync disabled — was causing catastrophic thread duplication
  // syncThreadsToServer();
  
  // Debounced archive: trigger background POST to /api/threads/:id/archive
  if (activeThreadId) {
    if (_archiveTimer) clearTimeout(_archiveTimer);
    _archiveTimer = setTimeout(() => {
      archiveThread(activeThreadId);
    }, ARCHIVE_DEBOUNCE_MS);
  }
}

// Archive thread to server (for episodic memory)
async function archiveThread(threadId) {
  const thread = threads.find(t => t.id === threadId);
  if (!thread || thread.messages.length === 0) return;
  
  try {
    await fetch(`/api/threads/${threadId}/archive`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ thread })
    });
    // Silent success — no toast needed for background operation
  } catch (err) {
    console.warn('[Archive] Failed to archive thread:', err);
  }
}

// ═══════════════════════════════════════════
// Server-Side Thread Persistence
// ═══════════════════════════════════════════
let _serverSyncPending = false;
let _serverSyncTimer = null;

// ── Server thread sync DISABLED ──
// Was causing a feedback loop: frontend creates thread → syncs to server →
// server broadcasts via WebSocket → frontend loads from server → creates duplicates → repeat forever.
// TODO: Re-implement with proper ID reconciliation and dedup.
function syncThreadsToServer() { /* disabled */ }
async function syncSingleThread(thread) { /* disabled */ }
async function loadThreadsFromServer() { return false; /* disabled */ }

function saveThreadsLocal() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(threads));
  if (_syncChannel) {
    try { _syncChannel.postMessage({ type: 'threads-updated', activeThreadId }); } catch {}
  }
}

// ═══════════════════════════════════════════
// Draft Persistence
// ═══════════════════════════════════════════
function loadDrafts() {
  try {
    const raw = localStorage.getItem(DRAFT_STORAGE_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch { return {}; }
}

function saveDraft() {
  if (!activeThreadId) return;
  const text = document.getElementById('inputBox').value;
  const drafts = loadDrafts();
  if (text.trim()) {
    drafts[activeThreadId] = text;
  } else {
    delete drafts[activeThreadId];
  }
  localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(drafts));
}

function restoreDraft() {
  if (!activeThreadId) return;
  const drafts = loadDrafts();
  const inputBox = document.getElementById('inputBox');
  const draft = drafts[activeThreadId] || '';
  inputBox.value = draft;
  autoResize(inputBox);
  updateCharCount();
  updateSendBtn();
}

function clearDraft() {
  if (!activeThreadId) return;
  const drafts = loadDrafts();
  delete drafts[activeThreadId];
  localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(drafts));
}

// ═══════════════════════════════════════════
// Character Count
// ═══════════════════════════════════════════
function updateCharCount() {
  const text = document.getElementById('inputBox').value;
  const el = document.getElementById('charCount');
  const len = text.length;
  el.textContent = len.toLocaleString();
  el.classList.toggle('visible', len > 0);
  el.classList.toggle('warn', len > 10000);
}

// ═══════════════════════════════════════════
// Context Health Indicator
// ═══════════════════════════════════════════
function updateContextHealth() {
  const thread = threads.find(t => t.id === activeThreadId);
  if (!thread || thread.messages.length === 0) {
    document.getElementById('contextHealthBar').style.display = 'none';
    return;
  }

  // Count total characters in all messages
  let totalChars = 0;
  for (const msg of thread.messages) {
    totalChars += (msg.content || '').length;
  }

  // Estimate tokens (chars / 4) and calculate percentage of 200k context
  const estimatedTokens = totalChars / 4;
  const contextLimit = 200000;
  const percentage = Math.round((estimatedTokens / contextLimit) * 100);

  // Update UI
  const bar = document.getElementById('contextHealthBar');
  const dot = document.getElementById('contextHealthDot');
  const text = document.getElementById('contextHealthText');

  if (percentage < 1) {
    bar.style.display = 'none';
    return;
  }

  bar.style.display = 'flex';
  text.textContent = `${percentage}% context`;

  // Color code
  dot.className = 'context-health-dot';
  if (percentage < 50) {
    dot.classList.add('green');
  } else if (percentage < 75) {
    dot.classList.add('yellow');
  } else if (percentage < 90) {
    dot.classList.add('orange');
  } else {
    dot.classList.add('red');
  }

  // Add tooltip if over 80%
  if (percentage > 80) {
    text.title = 'Context getting full. Consider resuming this thread.';
  } else {
    text.title = '';
  }
}

// ═══════════════════════════════════════════
// Cross-Tab Sync
// ═══════════════════════════════════════════
let _syncChannel = null;
let _syncPaused = false;

function initCrossTabSync() {
  try {
    _syncChannel = new BroadcastChannel('vektor_sync');
    _syncChannel.onmessage = (e) => {
      if (_syncPaused) return;
      if (e.data?.type === 'threads-updated') {
        reloadThreadsFromStorage();
      }
    };
  } catch {}

  window.addEventListener('storage', (e) => {
    if (_syncPaused) return;
    if (e.key === STORAGE_KEY && e.newValue) {
      reloadThreadsFromStorage();
    }
  });

  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && !_syncPaused) {
      reloadThreadsFromStorage();
    }
  });
}

function reloadThreadsFromStorage() {
  const previousActiveId = activeThreadId;
  loadThreads();
  threads.forEach(t => {
    if (!t.mode) t.mode = 'direct';
    if (!t.participants) t.participants = ['main'];
    if (t.mode === 'direct' && !t.agentId) t.agentId = 'main';
  });
  renderThreadList();
  if (previousActiveId && threads.find(t => t.id === previousActiveId)) {
    activeThreadId = previousActiveId;
    renderMessages();
    renderThreadList();
  } else if (threads.length > 0) {
    switchThread(threads[0].id);
  }
}

// ═══════════════════════════════════════════
// WebSocket Client (Real-Time)
// ═══════════════════════════════════════════
let _ws = null;
let _wsReconnectTimer = null;

function initWebSocket() {
  const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${location.host}/ws`;
  
  try {
    _ws = new WebSocket(wsUrl);
    
    _ws.onopen = () => {
      console.log('[WS] Connected');
      // Subscribe to active thread
      if (activeThreadId) {
        _ws.send(JSON.stringify({ type: 'subscribe', threadId: activeThreadId }));
      }
    };
    
    _ws.onmessage = (event) => {
      try {
        const msg = JSON.parse(event.data);
        handleWSEvent(msg);
      } catch {}
    };
    
    _ws.onclose = () => {
      console.log('[WS] Disconnected — reconnecting in 5s');
      _ws = null;
      _wsReconnectTimer = setTimeout(initWebSocket, 5000);
    };
    
    _ws.onerror = () => {
      _ws?.close();
    };
  } catch {
    _wsReconnectTimer = setTimeout(initWebSocket, 5000);
  }
}

function handleWSEvent(msg) {
  switch (msg.type) {
    case 'connected':
      console.log(`[WS] Client ${msg.clientId} at ${msg.serverTime}`);
      break;
    case 'tool_use':
      // Show tool use notification
      setTypingIndicator(true, 'using tools');
      break;
    case 'stream_done':
      setTypingIndicator(false);
      break;
    case 'notification':
      addNotification(msg.notification);
      break;
    case 'thread_created':
    case 'thread_updated':
    case 'thread_deleted':
      // Server thread sync disabled — ignore these events for now
      // loadThreadsFromServer().then(loaded => {
      //   if (loaded) renderThreadList();
      // });
      break;
  }
}

// ══════════════════════════════════════════════
// ── Notification System ──
// ══════════════════════════════════════════════

const NOTIF_STORAGE_KEY = 'vektor_notifications';
const NOTIF_ICONS = {
  task:    '⚡',
  build:   '⏀',
  agent:   '△',
  review:  '◈',
  alert:   '⚠',
  info:    '○',
  success: '✓',
  default: '●'
};

let _notifications = [];

function loadNotifications() {
  try {
    const raw = localStorage.getItem(NOTIF_STORAGE_KEY);
    _notifications = raw ? JSON.parse(raw) : [];
  } catch { _notifications = []; }
  // Also fetch from server on startup
  fetchNotifications();
}

function saveNotifications() {
  try { localStorage.setItem(NOTIF_STORAGE_KEY, JSON.stringify(_notifications)); } catch {}
}

async function fetchNotifications() {
  try {
    const resp = await fetch('/api/notifications');
    if (resp.ok) {
      const serverNotifs = await resp.json();
      // Merge — server is source of truth for unread state
      const existingIds = new Set(_notifications.map(n => n.id));
      for (const n of serverNotifs) {
        if (!existingIds.has(n.id)) {
          _notifications.unshift(n);
        }
      }
      // Sort newest first
      _notifications.sort((a, b) => b.timestamp - a.timestamp);
      // Cap at 50
      if (_notifications.length > 50) _notifications = _notifications.slice(0, 50);
      saveNotifications();
      renderNotifications();
    }
  } catch {}
}

function addNotification(notif) {
  const n = {
    id: notif.id || ('n_' + Date.now() + '_' + Math.random().toString(36).substr(2, 4)),
    type: notif.type || 'info',
    title: notif.title || 'Notification',
    body: notif.body || '',
    timestamp: notif.timestamp || Date.now(),
    read: false,
    action: notif.action || null  // { type: 'open-thread', threadId } or { type: 'navigate', url }
  };

  // Dedupe by id
  if (_notifications.find(x => x.id === n.id)) return;

  _notifications.unshift(n);
  if (_notifications.length > 50) _notifications.pop();
  saveNotifications();
  renderNotifications();

  // Pulse the bell
  const bell = document.getElementById('notifBell');
  bell.classList.remove('pulse');
  void bell.offsetWidth; // reflow
  bell.classList.add('pulse');

  // Show a toast too
  showToast(n.title);

  // Play subtle sound if available
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.frequency.value = 880;
    osc.type = 'sine';
    gain.gain.value = 0.08;
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.15);
  } catch {}
}

function renderNotifications() {
  const list = document.getElementById('notifList');
  const badge = document.getElementById('notifBadge');
  const bell = document.getElementById('notifBell');

  const unreadCount = _notifications.filter(n => !n.read).length;

  // Badge
  if (badge) {
    badge.textContent = unreadCount > 9 ? '9+' : unreadCount;
  }
  if (bell) {
    bell.classList.toggle('has-unread', unreadCount > 0);
  }
  // Nav rail notification dot
  const navDot = document.getElementById('navRailNotifDot');
  if (navDot) navDot.style.display = unreadCount > 0 ? '' : 'none';

  if (_notifications.length === 0) {
    list.innerHTML = '<div class="notification-empty"><div class="notification-empty-icon">⏀</div>No notifications</div>';
    return;
  }

  list.innerHTML = _notifications.map(n => {
    const icon = NOTIF_ICONS[n.type] || NOTIF_ICONS.default;
    const timeStr = formatNotifTime(n.timestamp);
    const unreadClass = n.read ? '' : ' unread';
    return `<div class="notification-item${unreadClass}" data-id="${n.id}" onclick="handleNotifClick('${n.id}')">
      <div class="notification-icon">${icon}</div>
      <div class="notification-content">
        <div class="notification-title">${escapeHtml(n.title)}</div>
        ${n.body ? `<div class="notification-body">${escapeHtml(n.body)}</div>` : ''}
        <div class="notification-time">${timeStr}</div>
      </div>
    </div>`;
  }).join('');
}

function formatNotifTime(ts) {
  const diff = Date.now() - ts;
  if (diff < 60000) return 'just now';
  if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
  if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
  return new Date(ts).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
}

function handleNotifClick(id) {
  const notif = _notifications.find(n => n.id === id);
  if (!notif) return;

  // Mark as read
  notif.read = true;
  saveNotifications();
  renderNotifications();
  markNotifReadOnServer(id);

  // Handle action
  if (notif.action) {
    if (notif.action.type === 'open-thread' && notif.action.threadId) {
      // Switch to that thread
      const thread = threads.find(t => t.id === notif.action.threadId);
      if (thread) {
        switchPanel('chat');
        selectThread(thread.id);
      }
    }
  }

  // Close the panel (animated)
  const _p = document.getElementById('notifPanel');
  _p.classList.remove('open');
  _p.addEventListener('transitionend', () => { _p.classList.remove('visible'); }, { once: true });
}

function toggleNotificationPanel(e) {
  e.stopPropagation();
  const panel = document.getElementById('notifPanel');
  const bell = document.getElementById('notifBell');

  if (!panel.classList.contains('open')) {
    // Opening: position, show, then animate
    const rect = bell.getBoundingClientRect();
    panel.style.bottom = (window.innerHeight - rect.bottom) + 'px';
    panel.style.top = 'auto';
    panel.style.left = (rect.right + 8) + 'px';

    panel.classList.add('visible');   // display: flex
    void panel.offsetHeight;          // force reflow
    panel.classList.add('open');      // triggers transition

    setTimeout(() => {
      document.addEventListener('click', closeNotifPanelOnOutside, { once: true });
    }, 0);
  } else {
    // Closing (animated)
    panel.classList.remove('open');
    panel.addEventListener('transitionend', () => {
      panel.classList.remove('visible');
    }, { once: true });
  }
}

function closeNotifPanelOnOutside(e) {
  const panel = document.getElementById('notifPanel');
  if (!panel.contains(e.target) && e.target.id !== 'notifBell' && !e.target.closest('#notifBell')) {
    panel.classList.remove('open');
    panel.addEventListener('transitionend', () => {
      panel.classList.remove('visible');
    }, { once: true });
  }
}

function clearAllNotifications() {
  _notifications = [];
  saveNotifications();
  renderNotifications();
  fetch('/api/notifications/clear', { method: 'POST' }).catch(() => {});
}

async function markNotifReadOnServer(id) {
  try { await fetch(`/api/notifications/${id}/read`, { method: 'POST' }); } catch {}
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// Load notifications on startup
loadNotifications();

// ══════════════════════════════════════════════
// ── Threads ──
// ══════════════════════════════════════════════
function createThread(name, agentId) {
  agentId = agentId || selectedAgentId;
  const agent = AGENTS[agentId] || AGENTS.main;
  const id = 'thread_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
  const thread = {
    id,
    name: name || `Thread ${threads.length + 1}`,
    messages: [],
    created: Date.now(),
    mode: 'direct',
    agentId: agentId,
    participants: [agentId]
  };
  threads.unshift(thread);
  saveThreads();
  renderThreadList();
  switchThread(id);
  // Server thread creation disabled — localStorage only for now
  // fetch('/api/threads', {
  //   method: 'POST',
  //   headers: { 'Content-Type': 'application/json' },
  //   body: JSON.stringify({ id: thread.id, name: thread.name, mode: thread.mode, participants: thread.participants })
  // }).catch(() => {});
  return thread;
}

function createGroupThread(name) {
  const id = 'thread_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
  const thread = {
    id,
    name: name || `Group ${threads.filter(t => t.mode === 'group').length + 1}`,
    messages: [],
    created: Date.now(),
    mode: 'group',
    participants: ['main', 'anima']
  };
  threads.unshift(thread);
  saveThreads();
  renderThreadList();
  switchThread(id);
  return thread;
}

function deleteThread(id, e) {
  e?.stopPropagation();
  if (threads.length <= 1) return;
  threads = threads.filter(t => t.id !== id);
  saveThreads();
  if (activeThreadId === id) {
    switchThread(threads[0]?.id);
  }
  renderThreadList();
}

async function resumeThread(id, e) {
  e?.stopPropagation();
  const originalThread = threads.find(t => t.id === id);
  if (!originalThread) return;
  
  try {
    // Call resume endpoint
    const res = await fetch(`/api/threads/${id}/resume`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ thread: originalThread })
    });
    
    if (!res.ok) {
      showToast('Failed to resume thread');
      return;
    }
    
    const data = await res.json();
    
    // Create new thread
    const newThreadId = 'thread_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);
    const newThread = {
      id: newThreadId,
      name: `[Resumed] ${data.originalThreadName}`,
      mode: originalThread.mode || 'direct',
      agentId: originalThread.agentId || 'main',
      participants: originalThread.participants || ['main'],
      messages: [],
      created: Date.now()
    };
    
    // Add context summary as a user message (so the LLM sees it as input context)
    const summaryMessage = {
      id: Math.random().toString(36).slice(2),
      role: 'user',
      content: `[Context: This thread continues from "${data.originalThreadName}". Summary of earlier discussion:\n${data.summary}\n\nThe following messages are carried over verbatim from the previous thread.]`,
      timestamp: Date.now()
    };
    newThread.messages.push(summaryMessage);
    
    // Add recent messages
    for (const msg of data.recentMessages) {
      newThread.messages.push({
        id: Math.random().toString(36).slice(2),
        role: msg.role,
        content: msg.content,
        timestamp: msg.timestamp,
        agentId: msg.agentId || newThread.agentId
      });
    }
    
    // Add to threads and switch
    threads.unshift(newThread);
    saveThreads();
    renderThreadList();
    switchThread(newThreadId);
    
    showToast(`Resumed with ${data.carriedOverMessages} recent messages`);
  } catch (err) {
    console.error('[Resume] Error:', err);
    showToast('Failed to resume thread');
  }
}

function startRename(id, e) {
  e?.stopPropagation();
  const el = document.querySelector(`[data-thread-id="${id}"] .thread-name`);
  const thread = threads.find(t => t.id === id);
  if (!el || !thread) return;
  
  const input = document.createElement('input');
  input.className = 'rename-input';
  input.value = thread.name;
  input.onblur = () => finishRename(id, input.value);
  input.onkeydown = (ev) => {
    if (ev.key === 'Enter') { ev.preventDefault(); input.blur(); }
    if (ev.key === 'Escape') { el.textContent = thread.name; }
  };
  el.textContent = '';
  el.appendChild(input);
  input.focus();
  input.select();
}

function finishRename(id, name) {
  const thread = threads.find(t => t.id === id);
  if (thread && name.trim()) {
    thread.name = name.trim();
    saveThreads();
  }
  renderThreadList();
}

function switchThread(id) {
  activeThreadId = id;
  const thread = threads.find(t => t.id === id);
  if (!thread) return;

  // Remember this thread as the last active for its agent
  if (thread.mode !== 'group') {
    agentLastThread[thread.agentId || 'main'] = id;
    saveAgentLastThread();
  }

  updateThreadHeader(thread);
  updateInputPlaceholder(thread);
  renderMessages();
  renderThreadList();
  renderAgentTabs();
  restoreDraft();
  updateContextHealth();
  document.getElementById('inputBox').focus();
}

// ═══════════════════════════════════════════
// Thread Header & Input Updates
// ═══════════════════════════════════════════
function updateThreadHeader(thread) {
  if (thread.mode === 'group') {
    const names = thread.participants.map(pid => {
      const agent = AGENTS[pid];
      return agent ? agent.name : '';
    }).filter(Boolean).join(' · ');
    updateBreadcrumb(['Chat', names || 'Group']);
  } else {
    const agent = AGENTS[thread.agentId || 'main'] || AGENTS.main;
    updateBreadcrumb(['Chat', thread.name || agent.name]);
  }
  // Also update the header glyph
  const glyphEl = document.getElementById('mainHeaderGlyph');
  if (glyphEl) {
    if (thread.mode === 'group') {
      glyphEl.textContent = '⏀△';
    } else {
      const agent = AGENTS[thread.agentId || 'main'] || AGENTS.main;
      glyphEl.textContent = agent.glyph;
      glyphEl.style.color = agent.accent;
    }
  }
}

function updateInputPlaceholder(thread) {
  const inputBox = document.getElementById('inputBox');
  if (thread.mode === 'group') {
    inputBox.placeholder = 'Message the group...';
  } else {
    const agent = AGENTS[thread.agentId || 'main'] || AGENTS.main;
    inputBox.placeholder = `Message ${agent.name.charAt(0) + agent.name.slice(1).toLowerCase()}...`;
  }
}

// ══════════════════════════════════════════════
// ── Timestamp Formatting ──
// ══════════════════════════════════════════════
function formatTimestamp(ts) {
  if (!ts) return '';
  const date = new Date(ts);
  const now = new Date();
  const isToday = date.toDateString() === now.toDateString();
  
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  const isYesterday = date.toDateString() === yesterday.toDateString();
  
  const time = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
  
  if (isToday) return time;
  if (isYesterday) return `Yesterday ${time}`;
  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' ' + time;
}

// ══════════════════════════════════════════════
// ── Render ──
// ══════════════════════════════════════════════
function renderThreadList() {
  const list = document.getElementById('threadList');
  // Filter threads by selected agent (group threads always visible)
  const visibleThreads = threads.filter(t =>
    t.mode === 'group' || t.agentId === selectedAgentId
  );
  list.innerHTML = visibleThreads.map(t => {
    const isGroup = t.mode === 'group';
    const directAgent = !isGroup ? (AGENTS[t.agentId || 'main'] || AGENTS.main) : null;
    const badge = isGroup
      ? `<span class="thread-mode-badge">${t.participants.map(p => AGENTS[p]?.glyph || '?').join('')}</span>`
      : `<span class="thread-mode-badge" style="color:${directAgent.accentDim}">${directAgent.glyph}</span>`;

    // Generate initials for collapsed icon
    const iconGlyph = isGroup ? '⏀△' : (directAgent ? directAgent.glyph : getThreadInitials(t));

    return `
    <div class="thread-item ${t.id === activeThreadId ? 'active' : ''}"
         data-thread-id="${t.id}"
         onclick="switchThread('${t.id}')"
         title="${escapeHtml(t.name)}">
      <div class="thread-icon">${iconGlyph}</div>
      <div class="thread-info">
        <div class="thread-name">${badge}${escapeHtml(t.name)}</div>
        <div class="thread-meta">${t.messages.length} messages${isGroup ? ' · group' : ''}</div>
      </div>
      <div class="thread-actions">
        ${t.messages.length >= 10 ? `<button class="thread-action-btn resume" onclick="resumeThread('${t.id}', event)" title="Resume">↪</button>` : ''}
        <button class="thread-action-btn" onclick="startRename('${t.id}', event)" title="Rename">✎</button>
        <button class="thread-action-btn delete" onclick="deleteThread('${t.id}', event)" title="Delete">✕</button>
      </div>
    </div>`;
  }).join('');
}

function getThreadInitials(thread) {
  const name = thread.name || 'New Chat';
  const words = name.split(/\s+/).filter(w => w.length > 0);
  if (words.length >= 2) {
    return (words[0][0] + words[1][0]).toUpperCase();
  }
  return name.substring(0, 2).toUpperCase();
}

function renderAgentTabs() {
  const tabsEl = document.getElementById('agentTabs');
  if (!tabsEl) return;

  const agentIds = ['main', 'anima'];
  tabsEl.innerHTML = agentIds.map(id => {
    const agent = AGENTS[id];
    const isActive = id === selectedAgentId;

    // Find current thread name for this agent
    let threadName = '';
    const lastThreadId = (id === selectedAgentId) ? activeThreadId : agentLastThread[id];
    if (lastThreadId) {
      const thread = threads.find(t => t.id === lastThreadId);
      if (thread) threadName = thread.name;
    }

    const threadSpan = threadName
      ? `<span class="agent-tab-thread">${escapeHtml(threadName)}</span>`
      : '';

    return `<div class="agent-tab ${isActive ? 'active' : ''}" onclick="switchAgentFromTab('${id}')" title="${agent.name}">
      <span class="agent-tab-glyph" style="color:${agent.accent}">${agent.glyph}</span>
      <span class="agent-tab-name">${agent.name}</span>
      ${threadSpan}
    </div>`;
  }).join('');
}

function switchAgentFromTab(agentId) {
  if (agentId === selectedAgentId) return;
  switchAgent(agentId);
}

let sidebarCollapsed = false;

function toggleSidebarCollapse() {
  sidebarCollapsed = !sidebarCollapsed;
  viewState.sidebarVisible = !sidebarCollapsed;
  const sidebar = document.getElementById('sidebar');
  sidebar.classList.toggle('collapsed', sidebarCollapsed);
  localStorage.setItem('vektor-sidebar-collapsed', sidebarCollapsed ? '1' : '0');
}

// Restore sidebar state on load
(function() {
  if (localStorage.getItem('vektor-sidebar-collapsed') === '1') {
    sidebarCollapsed = true;
    document.getElementById('sidebar').classList.add('collapsed');
  }
})();

function renderMessages() {
  const container = document.getElementById('messages');
  const thread = threads.find(t => t.id === activeThreadId);
  if (!thread || thread.messages.length === 0) {
    const isGroup = thread?.mode === 'group';
    const directAgent = !isGroup && thread ? (AGENTS[thread.agentId || 'main'] || AGENTS.main) : null;
    const glyph = isGroup ? '⏀△' : (directAgent ? directAgent.glyph : '⏀');
    const emptyText = isGroup ? 'START A GROUP CONVERSATION' : (directAgent ? `START A CONVERSATION WITH ${directAgent.name}` : 'START A CONVERSATION');
    const glyphColor = directAgent ? directAgent.accent : 'var(--accent)';
    container.innerHTML = `
      <div class="empty-state">
        <div class="empty-glyph" style="color:${glyphColor}">${glyph}</div>
        <div class="empty-text">${emptyText}</div>
      </div>`;
    return;
  }

  const isGroup = thread.mode === 'group';
  const threadAgentId = thread.agentId || 'main';

  container.innerHTML = thread.messages.map((m, i) => {
    const agentId = isGroup ? (m.agentId || 'main') : threadAgentId;
    const agent = AGENTS[agentId] || AGENTS.main;
    const agentClass = (isGroup || agentId !== 'main') && m.role === 'assistant' ? ` agent-${agentId}` : '';

    let attachmentHtml = '';
    if (m.attachments && m.attachments.length > 0) {
      attachmentHtml = '<div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:8px;">' +
        m.attachments.map(att => {
          if (att.type === 'image' && att.dataUrl) {
            return `<div class="message-image-container loading">
              <img class="message-image" src="${att.dataUrl}" alt="${escapeHtml(att.name)}" onload="this.parentElement.classList.remove('loading')" onerror="this.parentElement.classList.remove('loading')">
              <div class="message-image-overlay">
                <button class="image-overlay-btn" onclick="openLightbox(this.closest('.message-image-container').querySelector('img').src)" title="Expand">
                  <svg viewBox="0 0 24 24"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></svg>
                </button>
                <button class="image-overlay-btn" onclick="downloadImage(event, this.closest('.message-image-container').querySelector('img').src, '${escapeHtml(att.name)}')" title="Download">
                  <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                </button>
                <button class="image-overlay-btn" onclick="replyToImage(event, this.closest('.message-image-container').querySelector('img').src)" title="Reply to image">
                  <svg viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 11-2.12-9.36L23 10"/></svg>
                </button>
              </div>
            </div>`;
          } else {
            return `<div class="message-file-badge">
              <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14,2 14,8 20,8"/></svg>
              ${escapeHtml(att.name)} · ${formatBytes(att.size)}
            </div>`;
          }
        }).join('') +
        '</div>';
    }

    const avatarContent = m.role === 'user' ? 'R' : agent.glyph;
    const roleName = m.role === 'user' ? 'RILEY' : agent.name;
    const timestamp = formatTimestamp(m.timestamp);

    // Build message action buttons
    const copyBtn = `<button class="msg-action-btn" onclick="copyMessageText(${i})" title="Copy"><svg viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg></button>`;
    const editBtn = m.role === 'user' ? `<button class="msg-action-btn" onclick="startEditMessage(${i})" title="Edit"><svg viewBox="0 0 24 24"><path d="M17 3a2.828 2.828 0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg></button>` : '';
    const regenBtn = m.role === 'assistant' ? `<button class="msg-action-btn" onclick="regenerateMessage(${i})" title="Regenerate"><svg viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 11-2.12-9.36L23 10"/></svg></button>` : '';
    const deleteBtn = `<button class="msg-action-btn delete" onclick="confirmDeleteMessage(${i})" title="Delete"><svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg></button>`;

    const actionsHtml = `<div class="message-actions">${copyBtn}${editBtn}${regenBtn}${deleteBtn}</div>`;

    return `
      <div class="message ${m.role}${agentClass}" data-msg-index="${i}">
        ${actionsHtml}
        <div class="message-avatar">${avatarContent}</div>
        <div class="message-content">
          <div class="message-role-row">
            <span class="message-role">${roleName}</span>
            <span class="message-timestamp">${timestamp}</span>
          </div>
          ${attachmentHtml}
          <div class="message-text" id="msg-${i}">${formatMessage(m.content)}</div>
        </div>
      </div>`;
  }).join('');

  // Apply syntax highlighting to all code blocks
  applyHighlighting();
  scrollToBottom();
  updateContextHealth();
}

function scrollToBottom() {
  const container = document.getElementById('messages');
  requestAnimationFrame(() => {
    container.scrollTop = container.scrollHeight;
  });
}

// ══════════════════════════════════════════════
// ── Full Markdown Renderer (from scratch) ──
// ══════════════════════════════════════════════
function formatMessage(text) {
  if (!text) return '';
  text = preprocessLocalImages(text);
  return renderMarkdown(text);
}

function preprocessLocalImages(text) {
  const imgExtPattern = '\\.(png|jpg|jpeg|gif|webp|svg)';
  const pathPattern = `((?:/(?:Users|home|tmp)/|~/)\\S*?${imgExtPattern})`;
  
  // Pattern 2: rewrite markdown images with local paths: ![alt](/Users/...)
  text = text.replace(new RegExp(`!\\[([^\\]]*)\\]\\(${pathPattern}\\)`, 'gi'), (m, alt, path, ext) => {
    return `![${alt}](/api/local-image?path=${encodeURIComponent(path)})`;
  });
  
  // Pattern 1: bare file paths not already in markdown image syntax
  // Match paths that aren't preceded by ]( or src=" etc
  text = text.replace(new RegExp(`(?<!\\]\\()(?<!\\/api\\/local-image\\?path=)(?:^|(?<=\\s|\\(|\`))${pathPattern}(?=\\s|\\)|$|\`)`, 'gim'), (m, path, ext) => {
    const cleanPath = path.replace(/^`|`$/g, '');
    return `\n![image](/api/local-image?path=${encodeURIComponent(cleanPath)})\n`;
  });
  
  return text;
}

function renderMarkdown(text) {
  // Phase 1: Extract code blocks to prevent them from being processed
  const codeBlocks = [];
  let processed = text;
  
  // Extract fenced code blocks (``` ... ```)
  processed = processed.replace(/```(\w*)\n([\s\S]*?)```/g, (match, lang, code) => {
    const idx = codeBlocks.length;
    codeBlocks.push({ lang: lang || '', code: code });
    return `\x00CODEBLOCK${idx}\x00`;
  });

  // Extract inline code
  const inlineCodes = [];
  processed = processed.replace(/`([^`\n]+)`/g, (match, code) => {
    const idx = inlineCodes.length;
    inlineCodes.push(code);
    return `\x00INLINECODE${idx}\x00`;
  });

  // Phase 2: Escape HTML
  processed = escapeHtml(processed);

  // Phase 3: Block-level elements (process line by line)
  const lines = processed.split('\n');
  let html = '';
  let i = 0;
  // List state: stack of { type: 'ul'|'ol', indent: number }
  let listStack = [];
  let inBlockquote = false;
  let bqLines = []; // accumulate blockquote content

  // Close all open lists
  function closeAllLists() {
    while (listStack.length > 0) {
      const top = listStack.pop();
      html += top.type === 'ul' ? '</ul>' : '</ol>';
    }
  }

  function flushBlockquote() {
    if (inBlockquote) {
      // Render accumulated blockquote lines as inline-formatted content
      html += '<blockquote>' + bqLines.map(l => inlineFormat(l)).join('<br>') + '</blockquote>';
      inBlockquote = false;
      bqLines = [];
    }
  }

  // Get indent level (number of leading spaces)
  function getIndent(line) {
    const m = line.match(/^(\s*)/);
    return m ? m[1].length : 0;
  }

  while (i < lines.length) {
    const line = lines[i];
    const trimmed = line.trim();

    // Code block placeholder
    if (trimmed.match(/^\x00CODEBLOCK\d+\x00$/)) {
      closeAllLists();
      flushBlockquote();
      html += trimmed;
      i++;
      continue;
    }

    // Empty line
    if (trimmed === '') {
      closeAllLists();
      flushBlockquote();
      i++;
      continue;
    }

    // Horizontal rule
    if (/^(---|\*\*\*|___)$/.test(trimmed)) {
      closeAllLists();
      flushBlockquote();
      html += '<hr>';
      i++;
      continue;
    }

    // Headers (h1-h6)
    const headerMatch = trimmed.match(/^(#{1,6})\s+(.+)$/);
    if (headerMatch) {
      closeAllLists();
      flushBlockquote();
      const level = headerMatch[1].length;
      html += `<h${level}>${inlineFormat(headerMatch[2])}</h${level}>`;
      i++;
      continue;
    }

    // Table detection
    if (trimmed.startsWith('|') && i + 1 < lines.length && /^\|[\s\-:|]+\|$/.test(lines[i + 1].trim())) {
      closeAllLists();
      flushBlockquote();
      const tableResult = parseTable(lines, i);
      html += tableResult.html;
      i = tableResult.nextIndex;
      continue;
    }

    // Blockquote — accumulate contiguous > lines
    if (trimmed.startsWith('&gt; ') || trimmed === '&gt;') {
      closeAllLists();
      if (!inBlockquote) {
        inBlockquote = true;
        bqLines = [];
      }
      const quoteContent = trimmed.replace(/^&gt;\s?/, '');
      // Nested blockquote
      if (quoteContent.startsWith('&gt; ')) {
        // Flush current, add nested
        if (bqLines.length > 0) {
          html += '<blockquote>' + bqLines.map(l => inlineFormat(l)).join('<br>');
          bqLines = [];
        } else {
          html += '<blockquote>';
        }
        html += '<blockquote>' + inlineFormat(quoteContent.replace(/^&gt;\s?/, '')) + '</blockquote>';
        html += '</blockquote>';
        inBlockquote = false;
      } else {
        bqLines.push(quoteContent);
      }
      i++;
      continue;
    } else {
      flushBlockquote();
    }

    // List items (task, unordered, ordered) — with nesting support
    const indent = getIndent(line);
    const taskMatch = trimmed.match(/^[-*]\s+\[([ xX])\]\s+(.+)$/);
    const ulMatch = !taskMatch && trimmed.match(/^[-*+]\s+(.+)$/);
    const olMatch = !taskMatch && !ulMatch && trimmed.match(/^\d+\.\s+(.+)$/);

    if (taskMatch || ulMatch || olMatch) {
      const itemType = olMatch ? 'ol' : 'ul';
      // Determine nesting: compare indent to current stack
      // Each indent level ~2 spaces
      const level = Math.floor(indent / 2);

      // Pop lists that are deeper than current
      while (listStack.length > 0 && listStack[listStack.length - 1].indent > level) {
        const top = listStack.pop();
        html += top.type === 'ul' ? '</ul>' : '</ol>';
      }

      // If no list open or type changed at same level, open new
      if (listStack.length === 0 || listStack[listStack.length - 1].indent < level || listStack[listStack.length - 1].type !== itemType) {
        if (listStack.length > 0 && listStack[listStack.length - 1].indent === level && listStack[listStack.length - 1].type !== itemType) {
          // Same level, different type — close old, open new
          const top = listStack.pop();
          html += top.type === 'ul' ? '</ul>' : '</ol>';
        }
        html += itemType === 'ul' ? '<ul>' : '<ol>';
        listStack.push({ type: itemType, indent: level });
      }

      if (taskMatch) {
        const checked = taskMatch[1] !== ' ' ? ' checked' : '';
        html += `<li class="task-item"><input type="checkbox"${checked} disabled> ${inlineFormat(taskMatch[2])}</li>`;
      } else if (ulMatch) {
        html += `<li>${inlineFormat(ulMatch[1])}</li>`;
      } else {
        html += `<li>${inlineFormat(olMatch[1])}</li>`;
      }
      i++;
      continue;
    }

    // Not a list item — close all lists
    closeAllLists();

    // Regular paragraph
    let para = trimmed;
    while (i + 1 < lines.length) {
      const nextLine = lines[i + 1].trim();
      if (nextLine === '' || nextLine.match(/^#{1,6}\s/) || nextLine.match(/^[-*+]\s/) || nextLine.match(/^\d+\.\s/) || nextLine.startsWith('|') || nextLine.startsWith('&gt;') || nextLine.match(/^\x00CODEBLOCK/) || /^(---|\*\*\*|___)$/.test(nextLine) || nextLine.match(/^[-*]\s+\[[ xX]\]/)) {
        break;
      }
      i++;
      para += '<br>' + lines[i].trim();
    }
    html += `<p>${inlineFormat(para)}</p>`;
    i++;
  }

  closeAllLists();
  flushBlockquote();

  // Phase 4: Restore code blocks
  html = html.replace(/\x00CODEBLOCK(\d+)\x00/g, (_, idx) => {
    const block = codeBlocks[parseInt(idx)];
    return buildCodeBlockHtml(block.lang, block.code);
  });

  // Phase 5: Restore inline code
  html = html.replace(/\x00INLINECODE(\d+)\x00/g, (_, idx) => {
    return `<code>${escapeHtml(inlineCodes[parseInt(idx)])}</code>`;
  });

  return html;
}

// Inline formatting: bold, italic, strikethrough, links, images
function inlineFormat(text) {
  // Images: ![alt](url) — wrapped in premium container with overlay
  text = text.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<div class="message-image-container" style="margin:8px 0;"><img class="message-image" src="$2" alt="$1" style="max-width:100%;"><div class="message-image-overlay"><button class="image-overlay-btn" onclick="openLightbox(this.closest(\'.message-image-container\').querySelector(\'img\').src)" title="Expand"><svg viewBox="0 0 24 24"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></svg></button><button class="image-overlay-btn" onclick="downloadImage(event, this.closest(\'.message-image-container\').querySelector(\'img\').src, \'image\')" title="Download"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></button></div></div>');
  // Links: [text](url)
  text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
  // Bold + italic: ***text***
  text = text.replace(/\*\*\*([^*]+)\*\*\*/g, '<strong><em>$1</em></strong>');
  // Bold: **text**
  text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  // Italic: *text*
  text = text.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
  // Strikethrough: ~~text~~
  text = text.replace(/~~([^~]+)~~/g, '<del>$1</del>');
  // Restore inline code placeholders (they were already extracted, no action needed)
  return text;
}

// Parse markdown table from lines
function parseTable(lines, startIdx) {
  let i = startIdx;
  const headerLine = lines[i].trim();
  i++; // skip separator
  const sepLine = lines[i].trim();
  i++;

  const headers = headerLine.split('|').filter(c => c.trim() !== '').map(c => c.trim());
  
  // Parse alignment from separator
  const aligns = sepLine.split('|').filter(c => c.trim() !== '').map(c => {
    const t = c.trim();
    if (t.startsWith(':') && t.endsWith(':')) return 'center';
    if (t.endsWith(':')) return 'right';
    return 'left';
  });

  let html = '<div class="table-wrapper"><table><thead><tr>';
  headers.forEach((h, idx) => {
    const align = aligns[idx] || 'left';
    // Text is already HTML-escaped from Phase 2, just apply inline formatting
    html += `<th style="text-align:${align}">${inlineFormat(h)}</th>`;
  });
  html += '</tr></thead><tbody>';

  while (i < lines.length && lines[i].trim().startsWith('|')) {
    const cells = lines[i].trim().split('|').filter(c => c.trim() !== '').map(c => c.trim());
    html += '<tr>';
    cells.forEach((cell, idx) => {
      const align = aligns[idx] || 'left';
      html += `<td style="text-align:${align}">${inlineFormat(cell)}</td>`;
    });
    html += '</tr>';
    i++;
  }

  html += '</tbody></table></div>';
  return { html, nextIndex: i };
}

// Build code block HTML with header, line numbers, and highlighting
function buildCodeBlockHtml(lang, code) {
  // Remove trailing newline
  const trimmedCode = code.replace(/\n$/, '');
  const lineCount = trimmedCode.split('\n').length;
  const lineNums = Array.from({ length: lineCount }, (_, i) => `<span>${i + 1}</span>`).join('');
  const langLabel = lang ? lang.toUpperCase() : 'CODE';
  
  // We'll encode the raw code for copy
  const encodedCode = btoa(unescape(encodeURIComponent(trimmedCode)));

  return `<div class="code-block-wrapper">
    <div class="code-block-header">
      <span class="code-block-lang">${escapeHtml(langLabel)}</span>
      <div class="code-block-actions">
        <button class="code-action-btn" onclick="copyCodeBlockB64(this, '${encodedCode}')">
          <svg viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
          Copy
        </button>
        <button class="code-action-btn" onclick="openCodeInCanvasB64('${encodedCode}', '${escapeHtml(langLabel)}')">Canvas</button>
      </div>
    </div>
    <div class="code-block-body">
      <div class="code-line-numbers">${lineNums}</div>
      <pre class="code-block-code"><code class="language-${lang || 'plaintext'}">${escapeHtml(trimmedCode)}</code></pre>
    </div>
  </div>`;
}

// Apply highlight.js to all code blocks (debounced during streaming)
let _hlPending = false;
function applyHighlighting() {
  if (_hlPending) return;
  _hlPending = true;
  requestAnimationFrame(() => {
    _hlPending = false;
    document.querySelectorAll('.code-block-code code:not(.hljs)').forEach(block => {
      try { hljs.highlightElement(block); } catch(e) {}
    });
  });
}

function escapeHtml(str) {
  if (!str) return '';
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ══════════════════════════════════════════════
// ── Message Actions ──
// ══════════════════════════════════════════════

// Copy full message text
function copyMessageText(msgIndex) {
  const thread = threads.find(t => t.id === activeThreadId);
  if (!thread || !thread.messages[msgIndex]) return;
  const text = thread.messages[msgIndex].content || '';
  navigator.clipboard.writeText(text).then(() => {
    showToast('Copied to clipboard');
  });
}

// Edit message — transform into editable textarea
function startEditMessage(msgIndex) {
  const thread = threads.find(t => t.id === activeThreadId);
  if (!thread || !thread.messages[msgIndex] || thread.messages[msgIndex].role !== 'user') return;
  if (isStreaming) return;
  
  const msgEl = document.getElementById(`msg-${msgIndex}`);
  if (!msgEl) return;

  const originalText = thread.messages[msgIndex].content || '';
  
  msgEl.innerHTML = `
    <textarea class="edit-message-area" id="editArea-${msgIndex}" oninput="this.style.height='auto';this.style.height=Math.min(this.scrollHeight,300)+'px'">${escapeHtml(originalText)}</textarea>
    <div class="edit-message-actions">
      <button class="edit-msg-btn save" onclick="submitEditMessage(${msgIndex})">Save & Resend</button>
      <button class="edit-msg-btn" onclick="cancelEditMessage(${msgIndex})">Cancel</button>
    </div>`;
  
  const ta = document.getElementById(`editArea-${msgIndex}`);
  ta.focus();
  ta.style.height = Math.min(ta.scrollHeight, 300) + 'px';
}

function cancelEditMessage(msgIndex) {
  const thread = threads.find(t => t.id === activeThreadId);
  if (!thread || !thread.messages[msgIndex]) return;
  const msgEl = document.getElementById(`msg-${msgIndex}`);
  if (msgEl) {
    msgEl.innerHTML = formatMessage(thread.messages[msgIndex].content);
    applyHighlighting();
  }
}

async function submitEditMessage(msgIndex) {
  const thread = threads.find(t => t.id === activeThreadId);
  if (!thread || isStreaming) return;
  
  const ta = document.getElementById(`editArea-${msgIndex}`);
  if (!ta) return;
  const newText = ta.value.trim();
  if (!newText) return;

  // Update message and remove everything after it
  thread.messages[msgIndex].content = newText;
  thread.messages[msgIndex].timestamp = Date.now();
  thread.messages = thread.messages.slice(0, msgIndex + 1);
  saveThreads();
  renderMessages();

  // Re-send from this point
  if (thread.mode === 'group') {
    await sendGroupMessage(thread, newText, []);
  } else {
    await sendDirectMessage(thread, newText, []);
  }
}

// Regenerate: re-send conversation up to that point
async function regenerateMessage(msgIndex) {
  const thread = threads.find(t => t.id === activeThreadId);
  if (!thread || isStreaming) return;
  
  const msg = thread.messages[msgIndex];
  if (msg.role !== 'assistant') return;

  // Find the last user message before this assistant message
  let lastUserText = '';
  for (let j = msgIndex - 1; j >= 0; j--) {
    if (thread.messages[j].role === 'user') {
      lastUserText = thread.messages[j].content || '';
      break;
    }
  }

  // Remove this assistant message and everything after
  thread.messages = thread.messages.slice(0, msgIndex);
  saveThreads();
  renderMessages();

  // Re-send
  if (thread.mode === 'group') {
    await sendGroupMessage(thread, lastUserText, []);
  } else {
    await sendDirectMessage(thread, lastUserText, []);
  }
}

// Delete message with confirmation
function confirmDeleteMessage(msgIndex) {
  const overlay = document.createElement('div');
  overlay.className = 'confirm-overlay';
  overlay.innerHTML = `
    <div class="confirm-dialog">
      <h3>Delete message?</h3>
      <p>This action cannot be undone.</p>
      <div class="confirm-actions">
        <button class="confirm-btn cancel" onclick="this.closest('.confirm-overlay').remove()">Cancel</button>
        <button class="confirm-btn danger" onclick="executeDeleteMessage(${msgIndex}); this.closest('.confirm-overlay').remove()">Delete</button>
      </div>
    </div>`;
  document.body.appendChild(overlay);
  // Close on overlay click
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.remove();
  });
}

function executeDeleteMessage(msgIndex) {
  const thread = threads.find(t => t.id === activeThreadId);
  if (!thread) return;
  thread.messages.splice(msgIndex, 1);
  saveThreads();
  renderMessages();
  showToast('Message deleted');
}

// Stop generation
function stopGeneration() {
  if (currentAbortController) {
    currentAbortController.abort();
    currentAbortController = null;
  }
}

// Handle send/stop button click
function handleSendClick() {
  if (isStreaming) {
    stopGeneration();
  } else {
    sendMessage();
  }
}

// Update send button to show stop state
function setSendButtonStreaming(streaming) {
  const btn = document.getElementById('sendBtn');
  if (streaming) {
    btn.innerHTML = '■';
    btn.classList.add('stop-btn');
    btn.disabled = false;
    btn.title = 'Stop generation';
  } else {
    btn.innerHTML = '↑';
    btn.classList.remove('stop-btn');
    btn.title = '';
    updateSendBtn();
  }
}

// Show/hide typing indicator
function setTypingIndicator(active, agentName) {
  const el = document.getElementById('typingIndicator');
  const label = document.getElementById('typingLabel');
  if (active) {
    label.textContent = agentName ? `${agentName} is thinking...` : 'thinking...';
    el.classList.add('active');
  } else {
    el.classList.remove('active');
  }
}

// ══════════════════════════════════════════════
// ── Input ──
// ══════════════════════════════════════════════
function handleKey(e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    if (isStreaming) return;
    sendMessage();
  }
}

function autoResize(el) {
  el.style.height = 'auto';
  el.style.height = Math.min(el.scrollHeight, 200) + 'px';
}

// ══════════════════════════════════════════════
// ── File & Image Upload ──
// ══════════════════════════════════════════════
function handleFileSelect(event) {
  handleFiles(event.target.files);
  event.target.value = '';
}

function handlePaste(event) {
  const items = event.clipboardData?.items;
  if (!items) return;
  
  const files = [];
  for (const item of items) {
    if (item.kind === 'file') {
      const file = item.getAsFile();
      if (file) files.push(file);
    }
  }
  if (files.length) {
    event.preventDefault();
    handleFiles(files);
  }
}

function mimeFromExt(name) {
  const ext = name.split('.').pop().toLowerCase();
  const map = {
    txt: 'text/plain', md: 'text/markdown', html: 'text/html', htm: 'text/html',
    csv: 'text/csv', json: 'application/json', pdf: 'application/pdf',
    jpg: 'image/jpeg', jpeg: 'image/jpeg', png: 'image/png',
    gif: 'image/gif', webp: 'image/webp'
  };
  return map[ext] || '';
}

function isTextMime(mime) {
  return mime && (mime.startsWith('text/') || mime === 'application/json');
}

function handleFiles(fileList) {
  for (const file of fileList) {
    const mime = file.type || mimeFromExt(file.name);
    const isImage = IMAGE_MIMES.includes(mime);
    const isFile = FILE_MIMES.includes(mime);
    
    if (!isImage && !isFile) {
      showToast(`Unsupported file type: ${mime || file.name}`);
      continue;
    }
    
    if (isImage && file.size > MAX_IMAGE_BYTES) {
      showToast(`Image too large: ${file.name}`);
      continue;
    }
    
    if (isFile && file.size > MAX_FILE_BYTES) {
      showToast(`File too large: ${file.name}`);
      continue;
    }

    if (isImage) {
      const reader = new FileReader();
      reader.onload = () => {
        const dataUrl = reader.result;
        const base64 = dataUrl.split(',')[1];
        pendingAttachments.push({
          type: 'image', name: file.name, size: file.size, mime,
          dataUrl, base64
        });
        renderAttachmentPreview();
        updateSendBtn();
      };
      reader.readAsDataURL(file);
    } else if (isTextMime(mime)) {
      const reader = new FileReader();
      reader.onload = () => {
        pendingAttachments.push({
          type: 'text-file', name: file.name, size: file.size, mime,
          textContent: reader.result
        });
        renderAttachmentPreview();
        updateSendBtn();
      };
      reader.readAsText(file);
    } else {
      const reader = new FileReader();
      reader.onload = () => {
        const dataUrl = reader.result;
        const base64 = dataUrl.split(',')[1];
        pendingAttachments.push({
          type: 'file', name: file.name, size: file.size, mime,
          dataUrl, base64
        });
        renderAttachmentPreview();
        updateSendBtn();
      };
      reader.readAsDataURL(file);
    }
  }
}

function removeAttachment(index) {
  pendingAttachments.splice(index, 1);
  renderAttachmentPreview();
  updateSendBtn();
}

function renderAttachmentPreview() {
  const container = document.getElementById('attachmentPreview');
  
  if (pendingAttachments.length === 0) {
    container.classList.remove('has-items');
    container.innerHTML = '';
    return;
  }
  
  container.classList.add('has-items');
  container.innerHTML = pendingAttachments.map((att, i) => {
    if (att.type === 'image') {
      return `
        <div class="attachment-item image">
          <img src="${att.dataUrl}" alt="${escapeHtml(att.name)}">
          <button class="attachment-remove" onclick="removeAttachment(${i})">✕</button>
        </div>`;
    } else {
      return `
        <div class="attachment-item file">
          <div class="attachment-file-icon">📄</div>
          <div class="attachment-file-info">
            <div class="attachment-file-name">${escapeHtml(att.name)}</div>
            <div class="attachment-file-size">${formatBytes(att.size)}</div>
          </div>
          <button class="attachment-remove" onclick="removeAttachment(${i})">✕</button>
        </div>`;
    }
  }).join('');
}

function formatBytes(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

// Track current lightbox state for image gallery navigation
let lightboxImages = [];
let lightboxIndex = 0;

function openLightbox(src) {
  // Collect all images in current message view for gallery navigation
  lightboxImages = [];
  document.querySelectorAll('#messages .message-image, #messages .message-text img').forEach(img => {
    if (img.src) lightboxImages.push(img.src);
  });
  lightboxIndex = lightboxImages.indexOf(src);
  if (lightboxIndex === -1) {
    lightboxImages = [src];
    lightboxIndex = 0;
  }

  document.getElementById('lightboxImg').src = src;
  document.getElementById('lightbox').classList.add('active');

  // Show counter if multiple images
  const counter = document.getElementById('lightboxCounter');
  if (lightboxImages.length > 1) {
    counter.textContent = `${lightboxIndex + 1} / ${lightboxImages.length}`;
    counter.style.display = '';
  } else {
    counter.style.display = 'none';
  }

  document.body.style.overflow = 'hidden';
}

function closeLightbox(e) {
  if (e) e.stopPropagation();
  document.getElementById('lightbox').classList.remove('active');
  document.getElementById('lightboxImg').src = '';
  document.body.style.overflow = '';
}

function downloadLightboxImage(e) {
  e.stopPropagation();
  const src = document.getElementById('lightboxImg').src;
  if (!src) return;
  const a = document.createElement('a');
  a.href = src;
  a.download = `image-${Date.now()}.png`;
  a.click();
}

function downloadImage(e, src, name) {
  e.stopPropagation();
  const a = document.createElement('a');
  a.href = src;
  a.download = name || `image-${Date.now()}.png`;
  a.click();
}

function replyToImage(e, src) {
  e.stopPropagation();
  // Add image reference as pending attachment
  pendingAttachments.push({
    type: 'image',
    name: 'Referenced image',
    dataUrl: src,
    size: 0
  });
  renderAttachmentPreview();
  // Focus input and add contextual placeholder
  const inputBox = document.getElementById('inputBox');
  inputBox.placeholder = 'Describe changes to this image...';
  inputBox.focus();
  showToast('Image attached — describe your changes');
}

// Keyboard & click handlers for lightbox
document.addEventListener('keydown', (e) => {
  if (!document.getElementById('lightbox').classList.contains('active')) return;
  if (e.key === 'Escape') closeLightbox();
  if (e.key === 'ArrowRight' && lightboxImages.length > 1) {
    lightboxIndex = (lightboxIndex + 1) % lightboxImages.length;
    document.getElementById('lightboxImg').src = lightboxImages[lightboxIndex];
    document.getElementById('lightboxCounter').textContent = `${lightboxIndex + 1} / ${lightboxImages.length}`;
  }
  if (e.key === 'ArrowLeft' && lightboxImages.length > 1) {
    lightboxIndex = (lightboxIndex - 1 + lightboxImages.length) % lightboxImages.length;
    document.getElementById('lightboxImg').src = lightboxImages[lightboxIndex];
    document.getElementById('lightboxCounter').textContent = `${lightboxIndex + 1} / ${lightboxImages.length}`;
  }
});

// Click background to close lightbox (not toolbar or image)
document.getElementById('lightbox')?.addEventListener('click', (e) => {
  if (e.target === document.getElementById('lightbox')) closeLightbox();
});

// ══════════════════════════════════════════════
// ── API Message Builders ──
// ══════════════════════════════════════════════
function buildResponsesInput(messages, attachments) {
  const input = [];
  
  for (let i = 0; i < messages.length - 1; i++) {
    const m = messages[i];
    input.push({
      type: 'message',
      role: m.role,
      content: m.content || ''
    });
  }
  
  const lastMsg = messages[messages.length - 1];
  const contentParts = [];
  
  if (lastMsg.content) {
    contentParts.push({
      type: 'input_text',
      text: lastMsg.content
    });
  }
  
  for (const att of attachments) {
    if (att.type === 'image') {
      contentParts.push({
        type: 'input_image',
        source: {
          type: 'base64',
          media_type: att.mime,
          data: att.base64
        }
      });
    } else {
      contentParts.push({
        type: 'input_file',
        source: {
          type: 'base64',
          media_type: att.mime,
          data: att.base64,
          filename: att.name
        }
      });
    }
  }
  
  if (!lastMsg.content && contentParts.length > 0) {
    contentParts.unshift({
      type: 'input_text',
      text: 'Here is the attached file.'
    });
  }
  
  input.push({
    type: 'message',
    role: 'user',
    content: contentParts
  });
  
  return input;
}

// ═══════════════════════════════════════════
// Group Chat: Build context messages for a specific agent
// ═══════════════════════════════════════════
function buildGroupChatMessages(thread, targetAgentId, messageContent) {
  const participantNames = thread.participants.map(p => `${AGENTS[p]?.name || p} (AI)`).join(', ');
  const systemNote = `This is a group conversation between Riley (human), ${participantNames}. When other AI participants have spoken, their messages appear with their name prefixed. Respond naturally as yourself — don't prefix your own name.`;

  const messages = [];
  messages.push({ role: 'system', content: systemNote });

  const allMessages = thread.messages;
  for (let i = 0; i < allMessages.length; i++) {
    const m = allMessages[i];
    if (m.role === 'user') {
      messages.push({ role: 'user', content: m.content || '' });
    } else if (m.role === 'assistant') {
      const msgAgentId = m.agentId || 'main';
      const msgAgent = AGENTS[msgAgentId];
      
      if (msgAgentId === targetAgentId) {
        if (m.content) {
          messages.push({ role: 'assistant', content: m.content });
        }
      } else {
        if (m.content) {
          messages.push({ role: 'user', content: `[${msgAgent?.name || msgAgentId} said]: ${m.content}` });
        }
      }
    }
  }

  return messages;
}

function buildGroupResponsesInput(thread, targetAgentId, attachments) {
  const participantNames = thread.participants.map(p => `${AGENTS[p]?.name || p} (AI)`).join(', ');
  const systemNote = `This is a group conversation between Riley (human), ${participantNames}. When other AI participants have spoken, their messages appear with their name prefixed. Respond naturally as yourself — don't prefix your own name.`;

  const input = [];
  input.push({ type: 'message', role: 'system', content: systemNote });

  const allMessages = thread.messages;
  for (let i = 0; i < allMessages.length - 1; i++) {
    const m = allMessages[i];
    if (m.role === 'user') {
      input.push({ type: 'message', role: 'user', content: m.content || '' });
    } else if (m.role === 'assistant') {
      const msgAgentId = m.agentId || 'main';
      const msgAgent = AGENTS[msgAgentId];
      if (msgAgentId === targetAgentId) {
        if (m.content) input.push({ type: 'message', role: 'assistant', content: m.content });
      } else {
        if (m.content) input.push({ type: 'message', role: 'user', content: `[${msgAgent?.name || msgAgentId} said]: ${m.content}` });
      }
    }
  }

  const lastMsg = allMessages[allMessages.length - 1];
  const contentParts = [];
  
  if (lastMsg?.content) {
    contentParts.push({ type: 'input_text', text: lastMsg.content });
  }
  
  for (const att of attachments) {
    if (att.type === 'image') {
      contentParts.push({
        type: 'input_image',
        source: { type: 'base64', media_type: att.mime, data: att.base64 }
      });
    } else {
      contentParts.push({
        type: 'input_file',
        source: { type: 'base64', media_type: att.mime, data: att.base64, filename: att.name }
      });
    }
  }
  
  if (!lastMsg?.content && contentParts.length > 0) {
    contentParts.unshift({ type: 'input_text', text: 'Here is the attached file.' });
  }
  
  input.push({ type: 'message', role: 'user', content: contentParts });
  
  return input;
}

// ══════════════════════════════════════════════
// ── Send Message ──
// ══════════════════════════════════════════════
async function sendMessage() {
  const inputEl = document.getElementById('inputBox');
  const text = inputEl.value.trim();
  if ((!text && pendingAttachments.length === 0) || isStreaming) return;

  const thread = threads.find(t => t.id === activeThreadId);
  if (!thread) return;

  // Capture attachments before clearing
  const attachments = [...pendingAttachments];
  const hasAttachments = attachments.length > 0;

  // Build user message
  const userMessage = {
    role: 'user',
    content: text,
    timestamp: Date.now(),
    attachments: hasAttachments ? attachments.map(a => ({
      type: a.type,
      name: a.name,
      size: a.size,
      mime: a.mime,
      dataUrl: a.type === 'image' ? a.dataUrl : null
    })) : undefined
  };

  thread.messages.push(userMessage);
  
  // Clear UI
  inputEl.value = '';
  inputEl.style.height = 'auto';
  pendingAttachments = [];
  renderAttachmentPreview();
  updateCharCount();
  clearDraft();
  document.getElementById('sendBtn').disabled = true;
  saveThreads();

  // Route to group or direct send
  if (thread.mode === 'group') {
    await sendGroupMessage(thread, text, attachments);
  } else {
    await sendDirectMessage(thread, text, attachments);
  }
}

// ═══════════════════════════════════════════
// Direct Message Send
// ═══════════════════════════════════════════
async function sendDirectMessage(thread, text, attachments) {
  const hasAttachments = attachments.length > 0;
  
  renderMessages();

  // Add placeholder assistant message
  const directAgentId = thread.agentId || 'main';
  thread.messages.push({ role: 'assistant', content: '', agentId: directAgentId, timestamp: Date.now() });
  renderMessages();

  const msgIdx = thread.messages.length - 1;
  const msgEl = document.getElementById(`msg-${msgIdx}`);
  if (msgEl) msgEl.classList.add('streaming-cursor', `cursor-${directAgentId}`);

  isStreaming = true;
  _syncPaused = true;
  setSendButtonStreaming(true);
  setTypingIndicator(true);

  // Create AbortController for this request
  currentAbortController = new AbortController();

  try {
    const textFiles = attachments.filter(a => a.type === 'text-file');
    const binaryFiles = attachments.filter(a => a.type === 'file' || a.type === 'image');
    const hasBinaryAttachments = binaryFiles.length > 0;

    let messageContent = text;
    if (textFiles.length > 0) {
      const fileBlocks = textFiles.map(f => 
        `\n\n--- FILE: ${f.name} (${formatBytes(f.size)}) ---\n${f.textContent}\n--- END FILE ---`
      ).join('');
      messageContent = (text || 'Here are the attached files:') + fileBlocks;
    }

    let response;

    if (hasBinaryAttachments) {
      const inputItems = buildResponsesInput(
        [...thread.messages.slice(0, -2), { role: 'user', content: messageContent }],
        binaryFiles
      );

      response = await fetch(GATEWAY_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${GATEWAY_TOKEN}`,
          'Content-Type': 'application/json',
          'x-openclaw-agent-id': directAgentId
        },
        body: JSON.stringify({
          model: `clawdbot:${directAgentId}`,
          input: inputItems,
          stream: true,
          user: `vektor-terminal-${activeThreadId}`
        }),
        signal: currentAbortController.signal
      });
    } else {
      const apiMessages = thread.messages.slice(0, -1).map((m, i) => ({
        role: m.role,
        content: (i === thread.messages.length - 2) ? messageContent : m.content
      }));

      response = await fetch(GATEWAY_URL_LEGACY, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${GATEWAY_TOKEN}`,
          'Content-Type': 'application/json',
          'x-openclaw-agent-id': directAgentId
        },
        body: JSON.stringify({
          model: `clawdbot:${directAgentId}`,
          messages: apiMessages,
          stream: true,
          user: `vektor-terminal-${activeThreadId}`
        }),
        signal: currentAbortController.signal
      });
    }

    if (!response.ok) {
      const errBody = await response.text();
      throw new Error(`HTTP ${response.status}: ${errBody || response.statusText}`);
    }

    setTypingIndicator(false); // Got first response, hide indicator
    await streamResponse(response, thread, msgIdx, msgEl);

    // Check for artifacts
    _lastDetectedLength = 0;
    checkForArtifacts();

    // Auto-name thread
    if (thread.messages.length === 2 && thread.name.startsWith('Thread ')) {
      const firstWords = text.split(' ').slice(0, 5).join(' ');
      thread.name = firstWords.length > 30 ? firstWords.slice(0, 30) + '…' : firstWords;
      updateThreadHeader(thread);
      renderThreadList();
    }

    saveThreads();
    renderThreadList();

  } catch (err) {
    if (err.name === 'AbortError') {
      // User stopped generation
      thread.messages[msgIdx].content += '\n\n*[Generation stopped]*';
      showToast('Generation stopped');
    } else {
      console.error('Stream error:', err);
      thread.messages[msgIdx].content = `⚠ Error: ${err.message}`;
    }
    if (msgEl) {
      msgEl.classList.remove('streaming-cursor', `cursor-${directAgentId}`);
      if (err.name === 'AbortError') {
        msgEl.innerHTML = formatMessage(thread.messages[msgIdx].content);
        applyHighlighting();
      } else {
        msgEl.innerHTML = `<span style="color:#c44">⚠ ${escapeHtml(err.message)}</span>`;
      }
    }
    saveThreads();
  } finally {
    isStreaming = false;
    _syncPaused = false;
    currentAbortController = null;
    setSendButtonStreaming(false);
    setTypingIndicator(false);
    renderMessages();
    renderThreadList();
  }
}

// ═══════════════════════════════════════════
// Group Message Send (parallel agents)
// ═══════════════════════════════════════════
async function sendGroupMessage(thread, text, attachments) {
  const hasAttachments = attachments.length > 0;
  
  renderMessages();

  // Add placeholder messages for each participant
  const agentMsgIndices = {};
  for (const agentId of thread.participants) {
    thread.messages.push({ role: 'assistant', content: '', agentId, timestamp: Date.now() });
    agentMsgIndices[agentId] = thread.messages.length - 1;
  }
  renderMessages();

  // Add streaming cursors
  for (const agentId of thread.participants) {
    const idx = agentMsgIndices[agentId];
    const el = document.getElementById(`msg-${idx}`);
    if (el) {
      el.classList.add('streaming-cursor', `cursor-${agentId}`);
    }
  }

  isStreaming = true;
  _syncPaused = true;
  activeGroupStreams = thread.participants.length;
  setSendButtonStreaming(true);
  setTypingIndicator(true, 'Agents are');
  currentAbortController = new AbortController();

  // Prepare text file content
  const textFiles = attachments.filter(a => a.type === 'text-file');
  const binaryFiles = attachments.filter(a => a.type === 'file' || a.type === 'image');
  const hasBinaryAttachments = binaryFiles.length > 0;

  let messageContent = text;
  if (textFiles.length > 0) {
    const fileBlocks = textFiles.map(f => 
      `\n\n--- FILE: ${f.name} (${formatBytes(f.size)}) ---\n${f.textContent}\n--- END FILE ---`
    ).join('');
    messageContent = (text || 'Here are the attached files:') + fileBlocks;
  }

  const userMsgIdx = thread.messages.length - thread.participants.length - 1;
  if (messageContent !== text) {
    thread.messages[userMsgIdx].content = messageContent;
  }

  // Fire parallel requests
  const promises = thread.participants.map(agentId => 
    streamAgentResponse(thread, agentId, agentMsgIndices[agentId], messageContent, binaryFiles, hasBinaryAttachments)
  );

  await Promise.allSettled(promises);

  // Auto-name thread
  const userMsgCount = thread.messages.filter(m => m.role === 'user').length;
  if (userMsgCount === 1 && thread.name.startsWith('Group ')) {
    const firstWords = text.split(' ').slice(0, 5).join(' ');
    thread.name = firstWords.length > 30 ? firstWords.slice(0, 30) + '…' : firstWords;
    updateThreadHeader(thread);
    renderThreadList();
  }

  isStreaming = false;
  _syncPaused = false;
  activeGroupStreams = 0;
  currentAbortController = null;
  setSendButtonStreaming(false);
  setTypingIndicator(false);
  saveThreads();
  renderMessages();
  renderThreadList();
}

// Stream a single agent's response in a group chat
async function streamAgentResponse(thread, agentId, msgIdx, messageContent, binaryFiles, hasBinaryAttachments) {
  const agent = AGENTS[agentId];
  const msgEl = document.getElementById(`msg-${msgIdx}`);

  try {
    let response;

    if (hasBinaryAttachments) {
      const inputItems = buildGroupResponsesInput(thread, agentId, binaryFiles);

      response = await fetch(GATEWAY_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${GATEWAY_TOKEN}`,
          'Content-Type': 'application/json',
          'x-openclaw-agent-id': agentId
        },
        body: JSON.stringify({
          model: `clawdbot:${agentId}`,
          input: inputItems,
          stream: true,
          user: `vektor-terminal-${activeThreadId}`
        }),
        signal: currentAbortController?.signal
      });
    } else {
      const apiMessages = buildGroupChatMessages(thread, agentId, messageContent);

      response = await fetch(GATEWAY_URL_LEGACY, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${GATEWAY_TOKEN}`,
          'Content-Type': 'application/json',
          'x-openclaw-agent-id': agentId
        },
        body: JSON.stringify({
          model: `clawdbot:${agentId}`,
          messages: apiMessages,
          stream: true,
          user: `vektor-terminal-${activeThreadId}`
        }),
        signal: currentAbortController?.signal
      });
    }

    if (!response.ok) {
      const errBody = await response.text();
      throw new Error(`HTTP ${response.status}: ${errBody || response.statusText}`);
    }

    await streamResponse(response, thread, msgIdx, msgEl);

    _lastDetectedLength = 0;
    checkForArtifactsAtIndex(msgIdx);

  } catch (err) {
    if (err.name === 'AbortError') {
      thread.messages[msgIdx].content += '\n\n*[Generation stopped]*';
      if (msgEl) {
        msgEl.classList.remove('streaming-cursor', `cursor-${agentId}`);
        msgEl.innerHTML = formatMessage(thread.messages[msgIdx].content);
        applyHighlighting();
      }
    } else {
      console.error(`[${agent.name}] Stream error:`, err);
      thread.messages[msgIdx].content = `⚠ Error: ${err.message}`;
      if (msgEl) {
        msgEl.classList.remove('streaming-cursor', `cursor-${agentId}`);
        msgEl.innerHTML = `<span style="color:#c44">⚠ ${escapeHtml(err.message)}</span>`;
      }
    }
  } finally {
    activeGroupStreams--;
    saveThreads();
  }
}

// ═══════════════════════════════════════════
// Shared SSE Stream Reader
// ═══════════════════════════════════════════
async function streamResponse(response, thread, msgIdx, msgEl) {
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  let fullText = '';
  let firstChunk = true;
  var _streamRenderPending = false;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';

    for (const line of lines) {
      if (!line.startsWith('data: ')) continue;
      const data = line.slice(6).trim();
      if (data === '[DONE]') continue;

      try {
        const parsed = JSON.parse(data);
        
        let delta;
        if (parsed.choices?.[0]?.delta?.content) {
          delta = parsed.choices[0].delta.content;
        } else if (parsed.type === 'response.output_text.delta' && parsed.delta) {
          delta = parsed.delta;
        }
        
        if (delta) {
          if (firstChunk) {
            setTypingIndicator(false);
            firstChunk = false;
          }
          fullText += delta;
          thread.messages[msgIdx].content = fullText;
          // Throttle render during streaming to avoid jank on long messages
          if (!_streamRenderPending) {
            _streamRenderPending = true;
            requestAnimationFrame(() => {
              _streamRenderPending = false;
              if (msgEl) msgEl.innerHTML = formatMessage(fullText);
              applyHighlighting();
              scrollToBottom();
            });
          }
        }
      } catch {}
    }
  }

  // Finalize
  thread.messages[msgIdx].content = fullText;
  if (msgEl) {
    msgEl.classList.remove('streaming-cursor', 'cursor-main', 'cursor-anima');
    msgEl.innerHTML = formatMessage(fullText);
    applyHighlighting();
  }
}

// ══════════════════════════════════════════════
// ── Code Block Copy / Canvas Actions ──
// ══════════════════════════════════════════════
function copyCodeBlockB64(btn, b64) {
  try {
    const text = decodeURIComponent(escape(atob(b64)));
    navigator.clipboard.writeText(text).then(() => {
      const origHtml = btn.innerHTML;
      btn.innerHTML = `<svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg> Copied`;
      btn.classList.add('copied');
      setTimeout(() => { btn.innerHTML = origHtml; btn.classList.remove('copied'); }, 1500);
    });
  } catch(e) {
    const code = btn.closest('.code-block-wrapper')?.querySelector('code');
    if (code) navigator.clipboard.writeText(code.textContent);
    showToast('Copied!');
  }
}

function openCodeInCanvasB64(b64, langLabel) {
  try {
    const text = decodeURIComponent(escape(atob(b64)));
    const lang = langLabel?.toLowerCase() || '';
    const isRenderable = isRenderableHtml(text);
    const type = isRenderable ? 'html' : 'code';
    const title = generateArtifactTitle(text, lang, isRenderable);
    openCanvas(text, title, type, lang);
  } catch(e) {
    showToast('Failed to open in canvas');
  }
}

// Detect if content is renderable HTML
function isRenderableHtml(text) {
  const t = text.trim().toLowerCase();
  if (t.startsWith('<!doctype') || t.startsWith('<html')) return true;
  if (t.includes('<head') && t.includes('<body')) return true;
  // Has HTML tags and CSS or scripts
  const hasTags = /<[a-z][\s\S]*>/i.test(text);
  const hasStyle = /<style/i.test(text) || /style\s*=/i.test(text);
  const hasStructure = /<div|<section|<main|<header|<nav|<canvas/i.test(text);
  if (hasTags && (hasStyle || hasStructure)) return true;
  return false;
}

// Auto-generate title from code content
function generateArtifactTitle(text, lang, isHtml) {
  if (isHtml) {
    const titleMatch = text.match(/<title>([^<]+)<\/title>/i);
    if (titleMatch) return titleMatch[1].trim();
    const h1Match = text.match(/<h1[^>]*>([^<]+)<\/h1>/i);
    if (h1Match) return h1Match[1].trim();
  }
  // For markdown
  const mdTitle = text.match(/^#\s+(.+)$/m);
  if (mdTitle) return mdTitle[1].trim();
  // Python/JS docstrings and comments
  const docstringMatch = text.match(/^(?:"""|\'\'\')(.*?)(?:"""|\'\'\')/s);
  if (docstringMatch && docstringMatch[1].trim().length > 0 && docstringMatch[1].trim().length < 80) {
    return docstringMatch[1].trim().split('\n')[0].replace(/^[\s#/*'"]+|[\s#/*'"]+$/g, '');
  }
  const commentMatch = text.match(/^(?:\/\/|#|\/\*)\s*(.+?)(?:\*\/)?$/m);
  if (commentMatch && commentMatch[1].trim().length < 60) return commentMatch[1].trim();
  // Function/class name
  const funcMatch = text.match(/(?:function|def|class|const|let|var)\s+(\w+)/);
  if (funcMatch) return `${funcMatch[1]} — ${lang || 'code'}`;
  // Fallback: use first meaningful non-empty line, strip common prefixes
  const lines = text.trim().split('\n').filter(l => l.trim() && !l.trim().startsWith('import') && !l.trim().startsWith('from'));
  if (lines[0] && lines[0].length < 60) {
    const cleaned = lines[0].trim().replace(/^[#</*"'`]+\s*/, '').replace(/[#</*"'`]+\s*$/, '');
    if (cleaned.length > 3) return cleaned;
  }
  return lang ? `${lang.charAt(0).toUpperCase() + lang.slice(1)} Snippet` : 'Code';
}

// ══════════════════════════════════════════════
// ── Canvas System ──
// ══════════════════════════════════════════════
let canvasArtifacts = [];
let activeArtifactId = null;
let canvasViewMode = 'preview'; // 'preview' | 'code'
let canvasResizing = false;

function openCanvas(content, title, type = 'code', language = '') {
  const id = 'artifact_' + Date.now() + '_' + Math.random().toString(36).substr(2, 4);
  
  // Check for existing artifact with same title — update it (new version)
  const existing = canvasArtifacts.find(a => a.title === title);
  if (existing) {
    // Store version history
    if (!existing.versions) existing.versions = [];
    existing.versions.push({
      content: existing.content,
      timestamp: existing.updatedAt || Date.now()
    });
    existing.content = content;
    existing.type = type;
    existing.language = language || existing.language;
    existing.updatedAt = Date.now();
    activeArtifactId = existing.id;
  } else {
    const artifact = {
      id,
      title,
      content,
      type, // 'html' | 'code' | 'markdown'
      language: language || (type === 'html' ? 'html' : 'text'),
      versions: [],
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    canvasArtifacts.push(artifact);
    activeArtifactId = id;
  }
  
  // Default to preview for HTML, code for others
  if (type === 'html') {
    canvasViewMode = 'preview';
  } else if (type === 'markdown') {
    canvasViewMode = 'preview';
  } else {
    canvasViewMode = 'code';
  }
  
  const panel = document.getElementById('canvasPanel');
  const handle = document.getElementById('canvasResizeHandle');
  panel.classList.add('open');
  handle.classList.add('visible');
  
  updateCanvasHeader();
  renderCanvasBody();
  updateCanvasFooter();
}

function closeCanvas() {
  const panel = document.getElementById('canvasPanel');
  const handle = document.getElementById('canvasResizeHandle');
  panel.classList.remove('open');
  handle.classList.remove('visible');
  // Reset any inline styles from resize dragging
  panel.style.width = '';
  panel.style.minWidth = '';
  panel.style.maxWidth = '';
  // Close version panel too
  document.getElementById('canvasVersionPanel').classList.remove('open');
}

function switchArtifact(id) {
  activeArtifactId = id;
  const artifact = canvasArtifacts.find(a => a.id === id);
  if (artifact) {
    // Reset view mode for this artifact type
    if (artifact.type === 'html' || artifact.type === 'markdown') {
      canvasViewMode = 'preview';
    } else {
      canvasViewMode = 'code';
    }
  }
  // Ensure panel is open
  const panel = document.getElementById('canvasPanel');
  const handle = document.getElementById('canvasResizeHandle');
  if (!panel.classList.contains('open')) {
    panel.classList.add('open');
    handle.classList.add('visible');
  }
  closeArtifactDropdown();
  document.getElementById('canvasVersionPanel').classList.remove('open');
  updateCanvasHeader();
  renderCanvasBody();
  updateCanvasFooter();
}

function removeArtifact(id, e) {
  e?.stopPropagation();
  canvasArtifacts = canvasArtifacts.filter(a => a.id !== id);
  if (activeArtifactId === id) {
    activeArtifactId = canvasArtifacts[canvasArtifacts.length - 1]?.id || null;
  }
  if (canvasArtifacts.length === 0) {
    closeCanvas();
  } else {
    closeArtifactDropdown();
    updateCanvasHeader();
    renderCanvasBody();
    updateCanvasFooter();
  }
}

function switchCanvasTab(tab) {
  canvasViewMode = tab;
  document.getElementById('canvasTabPreview').classList.toggle('active', tab === 'preview');
  document.getElementById('canvasTabCode').classList.toggle('active', tab === 'code');
  renderCanvasBody();
}

// ── Canvas Header ──
function updateCanvasHeader() {
  const artifact = canvasArtifacts.find(a => a.id === activeArtifactId);
  
  // Update artifact count
  const count = canvasArtifacts.length;
  document.getElementById('canvasArtifactCount').textContent = count;
  document.getElementById('canvasArtifactPlural').textContent = count === 1 ? '' : 's';
  
  if (!artifact) {
    document.getElementById('canvasTitle').textContent = 'No artifacts';
    document.getElementById('canvasLangTag').textContent = '';
    document.getElementById('canvasArtifactSelect').style.display = 'none';
    return;
  }
  
  document.getElementById('canvasArtifactSelect').style.display = count > 1 ? 'block' : 'none';
  document.getElementById('canvasArtifactCount').textContent = count;
  document.getElementById('canvasArtifactPlural').textContent = count === 1 ? '' : 's';
  document.getElementById('canvasTitle').textContent = artifact.title;
  document.getElementById('canvasLangTag').textContent = artifact.language?.toUpperCase() || artifact.type.toUpperCase();
  
  // Update tab states
  const previewTab = document.getElementById('canvasTabPreview');
  const codeTab = document.getElementById('canvasTabCode');
  previewTab.classList.toggle('active', canvasViewMode === 'preview');
  codeTab.classList.toggle('active', canvasViewMode === 'code');
  
  // Disable preview tab for non-renderable code
  if (artifact.type === 'code') {
    previewTab.style.opacity = '0.4';
    previewTab.style.pointerEvents = 'none';
  } else {
    previewTab.style.opacity = '1';
    previewTab.style.pointerEvents = 'auto';
  }
}

// ── Canvas Body ──
function renderCanvasBody() {
  const body = document.getElementById('canvasBody');
  const artifact = canvasArtifacts.find(a => a.id === activeArtifactId);
  
  // Preserve version panel
  const versionPanel = document.getElementById('canvasVersionPanel');
  const versionPanelOpen = versionPanel?.classList.contains('open');
  
  if (!artifact) {
    body.innerHTML = `
      <div class="canvas-empty">
        <div class="canvas-empty-icon">◫</div>
        <div class="canvas-empty-text">NO ARTIFACTS</div>
      </div>`;
    body.appendChild(versionPanel);
    return;
  }
  
  if (canvasViewMode === 'preview') {
    if (artifact.type === 'html') {
      body.innerHTML = `<div class="canvas-body-iframe">
        <iframe class="canvas-iframe" sandbox="allow-scripts allow-same-origin" id="canvasIframe"></iframe>
      </div>`;
      const iframe = document.getElementById('canvasIframe');
      // Inject dark bg for partial HTML
      let htmlContent = artifact.content;
      if (!htmlContent.includes('<html') && !htmlContent.includes('<!DOCTYPE')) {
        htmlContent = `<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><style>body { margin: 0; }</style></head><body>${htmlContent}</body></html>`;
      }
      iframe.srcdoc = htmlContent;
    } else if (artifact.type === 'markdown') {
      body.innerHTML = `<div class="canvas-body-scroll">
        <div class="canvas-markdown">${renderCanvasMarkdownFull(artifact.content)}</div>
      </div>`;
    } else {
      // Code type — show code view even in "preview"
      renderCanvasCodeView(body, artifact);
    }
  } else {
    // Code view
    renderCanvasCodeView(body, artifact);
  }
  
  // Re-add version panel
  body.appendChild(versionPanel);
  if (versionPanelOpen) {
    versionPanel.classList.add('open');
    renderVersionList();
  }
}

function renderCanvasCodeView(container, artifact) {
  const langClass = artifact.language ? `language-${artifact.language.toLowerCase()}` : 'language-plaintext';
  const lines = artifact.content.split('\n');
  const lineNums = lines.map((_, i) => `<span>${i + 1}</span>`).join('');
  
  container.innerHTML = `<div class="canvas-code-view">
    <div style="display:flex;height:100%;overflow:auto;">
      <div class="code-line-numbers" style="padding:16px 12px 16px 12px;">${lineNums}</div>
      <pre style="flex:1;margin:0;padding:16px;overflow:visible;"><code class="${langClass}" id="canvasCodeBlock">${escapeHtml(artifact.content)}</code></pre>
    </div>
  </div>`;
  
  // Apply highlighting
  const codeEl = document.getElementById('canvasCodeBlock');
  if (codeEl) {
    try { hljs.highlightElement(codeEl); } catch(e) {}
  }
}

function updateCanvasFooter() {
  const artifact = canvasArtifacts.find(a => a.id === activeArtifactId);
  if (!artifact) {
    document.getElementById('canvasFooterInfo').textContent = 'No artifacts';
    document.getElementById('canvasVersionCount').textContent = '';
    return;
  }
  
  const lines = artifact.content.split('\n').length;
  const chars = artifact.content.length;
  document.getElementById('canvasFooterInfo').textContent = `${lines} lines · ${chars.toLocaleString()} chars`;
  
  const versions = artifact.versions?.length || 0;
  document.getElementById('canvasVersionCount').textContent = versions > 0 ? `v${versions + 1} · ${versions} prior` : 'v1';
}

// ── Artifact Dropdown ──
function toggleArtifactDropdown(e) {
  e?.stopPropagation();
  const dropdown = document.getElementById('canvasArtifactDropdown');
  const isOpen = dropdown.classList.contains('open');
  
  if (isOpen) {
    closeArtifactDropdown();
    return;
  }
  
  dropdown.innerHTML = canvasArtifacts.map(a => `
    <button class="canvas-artifact-option ${a.id === activeArtifactId ? 'active' : ''}"
            onclick="switchArtifact('${a.id}')">
      <span class="canvas-artifact-option-icon">${a.type === 'html' ? '◇' : a.type === 'markdown' ? '☰' : '⟨⟩'}</span>
      <span class="canvas-artifact-option-title">${escapeHtml(a.title)}</span>
    </button>
  `).join('');
  
  dropdown.classList.add('open');
  
  // Close on outside click
  setTimeout(() => {
    document.addEventListener('click', closeArtifactDropdownHandler, { once: true });
  }, 10);
}

function closeArtifactDropdownHandler(e) {
  if (!e.target.closest('.canvas-artifact-select')) {
    closeArtifactDropdown();
  }
}

function closeArtifactDropdown() {
  document.getElementById('canvasArtifactDropdown').classList.remove('open');
}

// ── Canvas Actions ──
function copyCanvasContent() {
  const artifact = canvasArtifacts.find(a => a.id === activeArtifactId);
  if (!artifact) return;
  navigator.clipboard.writeText(artifact.content).then(() => {
    showToast('Copied to clipboard');
  });
}

function downloadCanvasContent() {
  const artifact = canvasArtifacts.find(a => a.id === activeArtifactId);
  if (!artifact) return;
  
  let filename, mimeType;
  if (artifact.type === 'html') {
    filename = (artifact.title.replace(/[^a-zA-Z0-9_-]/g, '_') || 'artifact') + '.html';
    mimeType = 'text/html';
  } else if (artifact.type === 'markdown') {
    filename = (artifact.title.replace(/[^a-zA-Z0-9_-]/g, '_') || 'artifact') + '.md';
    mimeType = 'text/markdown';
  } else {
    const ext = artifact.language ? `.${artifact.language.toLowerCase()}` : '.txt';
    filename = (artifact.title.replace(/[^a-zA-Z0-9_-]/g, '_') || 'artifact') + ext;
    mimeType = 'text/plain';
  }
  
  const blob = new Blob([artifact.content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  showToast(`Downloaded ${filename}`);
}

function openCanvasInNewTab() {
  const artifact = canvasArtifacts.find(a => a.id === activeArtifactId);
  if (!artifact) return;
  
  if (artifact.type === 'html') {
    const blob = new Blob([artifact.content], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    window.open(url, '_blank');
    // Clean up after a delay
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  } else {
    // For non-HTML, open as text in new tab
    const blob = new Blob([artifact.content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    window.open(url, '_blank');
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }
}

// ── Version History ──
function toggleVersionHistory() {
  const panel = document.getElementById('canvasVersionPanel');
  const isOpen = panel.classList.contains('open');
  
  if (isOpen) {
    panel.classList.remove('open');
  } else {
    renderVersionList();
    panel.classList.add('open');
  }
}

function renderVersionList() {
  const artifact = canvasArtifacts.find(a => a.id === activeArtifactId);
  const list = document.getElementById('canvasVersionList');
  
  if (!artifact || !artifact.versions || artifact.versions.length === 0) {
    list.innerHTML = `<div style="padding:12px;color:var(--text-tertiary);font-size:11px;text-align:center;">No previous versions</div>`;
    return;
  }
  
  // Current version + history
  const versions = [
    { content: artifact.content, timestamp: artifact.updatedAt, isCurrent: true },
    ...artifact.versions.map(v => ({ ...v, isCurrent: false })).reverse()
  ];
  
  list.innerHTML = versions.map((v, i) => `
    <div class="canvas-version-item ${v.isCurrent ? 'active' : ''}"
         onclick="restoreVersion(${i}, ${v.isCurrent})">
      <div>${v.isCurrent ? 'Current' : 'Version ' + (versions.length - i)}</div>
      <div class="canvas-version-item-time">${formatTimestamp(v.timestamp)}</div>
    </div>
  `).join('');
}

function restoreVersion(versionIndex, isCurrent) {
  if (isCurrent) return;
  
  const artifact = canvasArtifacts.find(a => a.id === activeArtifactId);
  if (!artifact || !artifact.versions) return;
  
  // The version list is [current, newest_old, ..., oldest_old]
  // The versions array in artifact is [oldest, ..., newest]
  const reversedIdx = artifact.versions.length - versionIndex; // Map back to original index
  const targetVersion = artifact.versions[reversedIdx];
  if (!targetVersion) return;
  
  // Save current as a version
  artifact.versions.push({
    content: artifact.content,
    timestamp: artifact.updatedAt
  });
  
  // Restore
  artifact.content = targetVersion.content;
  artifact.updatedAt = Date.now();
  
  renderCanvasBody();
  updateCanvasFooter();
  renderVersionList();
  showToast('Version restored');
}

// ── Resize Handle ──
function initCanvasResize() {
  const handle = document.getElementById('canvasResizeHandle');
  const panel = document.getElementById('canvasPanel');
  const app = document.getElementById('app');
  
  let startX, startWidth;
  
  handle.addEventListener('mousedown', (e) => {
    e.preventDefault();
    canvasResizing = true;
    startX = e.clientX;
    startWidth = panel.getBoundingClientRect().width;
    
    handle.classList.add('dragging');
    document.body.classList.add('resizing');
    panel.classList.add('no-transition');
    
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  });
  
  function onMouseMove(e) {
    if (!canvasResizing) return;
    const dx = startX - e.clientX;
    const appWidth = app.getBoundingClientRect().width;
    let newWidth = startWidth + dx;
    
    // Enforce limits: min 300px, max 70% of app
    const maxWidth = appWidth * 0.7;
    const minWidth = 300;
    newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
    
    panel.style.width = newWidth + 'px';
    panel.style.minWidth = newWidth + 'px';
    panel.style.maxWidth = newWidth + 'px';
  }
  
  function onMouseUp() {
    canvasResizing = false;
    handle.classList.remove('dragging');
    document.body.classList.remove('resizing');
    panel.classList.remove('no-transition');
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', onMouseUp);
  }
}

// Canvas markdown renderer
function renderCanvasMarkdownFull(text) {
  if (!text) return '';
  // Re-use the main markdown renderer
  return renderMarkdown(text);
}

// ══════════════════════════════════════════════
// ── Artifact Detection ──
// ══════════════════════════════════════════════
function detectArtifacts(text) {
  const artifacts = [];
  const lines = text.split('\n');
  let i = 0;
  
  while (i < lines.length) {
    const line = lines[i];
    
    const openMatch = line.match(/^(`{3,})(markdown|html)\s*$/);
    if (openMatch) {
      const fenceChar = openMatch[1];
      const lang = openMatch[2];
      const fenceLen = fenceChar.length;
      const contentLines = [];
      let depth = 0;
      i++;
      
      while (i < lines.length) {
        const innerLine = lines[i];
        const fenceMatch = innerLine.match(/^(`{3,})(\w*)\s*$/);
        if (fenceMatch) {
          const innerFenceLen = fenceMatch[1].length;
          const innerLang = fenceMatch[2];
          
          if (innerFenceLen >= fenceLen && !innerLang && depth === 0) {
            break;
          } else if (innerLang) {
            depth++;
            contentLines.push(innerLine);
          } else if (depth > 0) {
            depth--;
            contentLines.push(innerLine);
          } else {
            contentLines.push(innerLine);
          }
        } else {
          contentLines.push(innerLine);
        }
        i++;
      }
      
      const content = contentLines.join('\n');
      
      if (lang === 'markdown') {
        const titleMatch = content.match(/^#\s+(.+)$/m);
        artifacts.push({
          content,
          title: titleMatch ? titleMatch[1] : 'Document',
          type: 'markdown'
        });
      } else if (lang === 'html') {
        const titleMatch = content.match(/<title>([^<]+)<\/title>/);
        artifacts.push({
          content,
          title: titleMatch ? titleMatch[1] : 'HTML Preview',
          type: 'html'
        });
      }
    }
    i++;
  }
  
  if (artifacts.length === 0) {
    const trimmed = text.trim();
    const headingCount = (trimmed.match(/^#{1,3}\s+.+$/gm) || []).length;
    if (headingCount >= 3 && trimmed.length > 500 && trimmed.startsWith('#')) {
      const titleMatch = trimmed.match(/^#\s+(.+)$/m);
      artifacts.push({
        content: trimmed,
        title: titleMatch ? titleMatch[1] : 'Document',
        type: 'markdown'
      });
    }
  }
  
  return artifacts;
}

let _lastDetectedLength = 0;

function checkForArtifacts() {
  const thread = threads.find(t => t.id === activeThreadId);
  if (!thread || thread.messages.length === 0) return;
  
  const lastMsg = thread.messages[thread.messages.length - 1];
  if (lastMsg.role !== 'assistant' || !lastMsg.content) return;
  
  if (lastMsg.content.length <= _lastDetectedLength + 100) return;
  _lastDetectedLength = lastMsg.content.length;
  
  const artifacts = detectArtifacts(lastMsg.content);
  artifacts.forEach(a => {
    if (a.content.length > 200) {
      openCanvas(a.content, a.title, a.type);
    }
  });
}

function checkForArtifactsAtIndex(msgIdx) {
  const thread = threads.find(t => t.id === activeThreadId);
  if (!thread || !thread.messages[msgIdx]) return;
  
  const msg = thread.messages[msgIdx];
  if (msg.role !== 'assistant' || !msg.content) return;
  
  const artifacts = detectArtifacts(msg.content);
  artifacts.forEach(a => {
    if (a.content.length > 200) {
      openCanvas(a.content, a.title, a.type);
    }
  });
}

// ══════════════════════════════════════════════
// ── COMMAND CENTER ──
// ══════════════════════════════════════════════

let currentPanel = 'chat';
let ccCache = { skills: null, history: null, cron: null, projects: null, memory: null, system: null, journal: null };
let journalPollTimer = null;
let ccFilters = { historyAgent: null, historySearch: '', skillsSearch: '', projectsSearch: '' };

const viewState = {
  activeSection: 'chat',
  sidebarVisible: true,
  scrollPositions: {},
  searchQueries: {},
  detailContext: null
};

const sectionLabels = {
  home: 'Home', chat: 'Chat', skills: 'Skills', history: 'Sessions',
  cron: 'Tasks', projects: 'Projects', memory: 'Memory', journal: 'Journal'
};

function switchSection(section) {
  // Save scroll position of current sidebar list
  const currentList = document.querySelector('.browse-panel.active .browse-list') || document.getElementById('threadList');
  if (currentList) {
    viewState.scrollPositions[viewState.activeSection] = currentList.scrollTop;
  }

  // Save search query if any
  const currentSearch = document.querySelector('.browse-panel.active .browse-search');
  if (currentSearch) {
    viewState.searchQueries[viewState.activeSection] = currentSearch.value;
  }

  viewState.activeSection = section;
  currentPanel = section === 'home' ? 'chat' : section;

  // Update nav-rail active states
  document.querySelectorAll('.nav-rail-btn[data-section]').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.section === section);
  });

  const threadList = document.getElementById('threadList');
  const browseNames = ['Skills', 'History', 'Cron', 'Projects', 'Memory', 'Journal'];
  const messagesEl = document.getElementById('messages');
  const inputArea = document.querySelector('.input-area');
  const mainHeader = document.querySelector('.main-header');
  const detailView = document.getElementById('detailView');
  const dashboardView = document.getElementById('dashboardView');
  const sidebar = document.getElementById('sidebar');

  // Hide all main views
  detailView.classList.remove('active');
  dashboardView.style.display = 'none';
  messagesEl.style.display = 'none';
  inputArea.style.display = 'none';
  if (mainHeader) mainHeader.style.display = '';

  if (section === 'home') {
    // Home: show dashboard, collapse sidebar
    sidebar.classList.add('collapsed');
    viewState.sidebarVisible = false;
    threadList.style.display = 'none';
    browseNames.forEach(p => {
      const el = document.getElementById('panel' + p);
      if (el) el.classList.remove('active');
    });
    dashboardView.style.display = '';
    updateBreadcrumb(['Home']);
    updateDashboardStats();
    // Deactivate all nav buttons for home
    document.querySelectorAll('.nav-rail-btn[data-section]').forEach(btn => {
      btn.classList.remove('active');
    });
    return;
  }

  // Ensure sidebar is visible
  sidebar.classList.remove('collapsed');
  viewState.sidebarVisible = true;

  if (section === 'chat') {
    threadList.style.display = '';
    browseNames.forEach(p => {
      const el = document.getElementById('panel' + p);
      if (el) el.classList.remove('active');
    });
    messagesEl.style.display = '';
    inputArea.style.display = '';
    updateBreadcrumb(['Chat']);
  } else {
    threadList.style.display = 'none';
    browseNames.forEach(p => {
      const el = document.getElementById('panel' + p);
      if (el) el.classList.toggle('active', p.toLowerCase() === section);
    });
    // Show empty main with section label
    updateBreadcrumb([sectionLabels[section] || section]);
    loadPanelData(section);
  }

  // Restore scroll position
  requestAnimationFrame(() => {
    const newList = document.querySelector('.browse-panel.active .browse-list') || (section === 'chat' ? document.getElementById('threadList') : null);
    if (newList && viewState.scrollPositions[section]) {
      newList.scrollTop = viewState.scrollPositions[section];
    }
    // Restore search query
    const newSearch = document.querySelector('.browse-panel.active .browse-search');
    if (newSearch && viewState.searchQueries[section]) {
      newSearch.value = viewState.searchQueries[section];
    }
  });
}

// Backwards compatibility alias
function switchPanel(panel) {
  switchSection(panel);
}

// ── Breadcrumb ──

function updateBreadcrumb(segments) {
  const bc = document.getElementById('breadcrumb');
  if (!bc) return;
  if (segments.length === 1) {
    bc.innerHTML = '<span class="breadcrumb-current">' + segments[0] + '</span>';
  } else {
    bc.innerHTML = segments.map((s, i) => {
      if (i < segments.length - 1) {
        return '<span class="breadcrumb-segment" onclick="breadcrumbBack(' + i + ')">' + s + '</span><span class="breadcrumb-separator">›</span>';
      }
      return '<span class="breadcrumb-current">' + s + '</span>';
    }).join('');
  }
}

function breadcrumbBack(index) {
  if (index === 0) {
    closeDetailView();
  }
}

// ── Dashboard Stats ──

function updateDashboardStats() {
  const statThreads = document.getElementById('statThreads');
  const statSkills = document.getElementById('statSkills');
  const statMemory = document.getElementById('statMemory');
  if (statThreads) statThreads.textContent = threads ? threads.length : '—';
  if (statSkills && ccCache.skills) statSkills.textContent = ccCache.skills.length;
  if (statMemory && ccCache.memory) statMemory.textContent = ccCache.memory.length;
}

async function loadPanelData(panel) {
  switch (panel) {
    case 'skills': return loadSkills();
    case 'history': return loadHistory();
    case 'cron': return loadCron();
    case 'projects': return loadProjects();
    case 'memory': return loadMemory();
    case 'journal': return loadJournal();
  }
}

// ── Skills ──

async function loadSkills() {
  if (ccCache.skills) return renderSkills(ccCache.skills);
  try {
    const res = await fetch(`/api/skills?agent=${selectedAgentId}`);
    const data = await res.json();
    ccCache.skills = data.skills;
    renderSkills(data.skills);
  } catch (err) {
    document.getElementById('skillsList').innerHTML = `<div class="browse-item-desc">Failed to load skills</div>`;
  }
}

function renderSkills(skills) {
  const search = ccFilters.skillsSearch.toLowerCase();
  const filtered = search
    ? skills.filter(s => s.name.toLowerCase().includes(search) || s.description.toLowerCase().includes(search))
    : skills;

  document.getElementById('skillsCount').textContent = `${filtered.length}`;
  const list = document.getElementById('skillsList');
  list.innerHTML = filtered.map(s => `
    <div class="browse-item" onclick="openSkillDetail('${s.id}')">
      <div class="browse-item-title">
        ${s.name}
        <span class="browse-tag ${s.source}">${s.source}</span>
      </div>
      <div class="browse-item-desc">${escapeHtml(s.description || 'No description')}</div>
    </div>
  `).join('');
}

function filterSkills() {
  ccFilters.skillsSearch = document.getElementById('skillsSearch').value;
  if (ccCache.skills) renderSkills(ccCache.skills);
}

async function openSkillDetail(id) {
  try {
    const res = await fetch(`/api/skills/${id}?agent=${selectedAgentId}`);
    const skill = await res.json();
    showDetailView(skill.name, `${skill.source} skill · ${(skill.files || []).length} files`, renderMarkdownBasic(skill.content || 'No content'));
  } catch {
    showDetailView(id, 'Error', '<p>Failed to load skill details</p>');
  }
}

// ── History (Sessions) ──

async function loadHistory() {
  if (ccCache.history) return renderHistory(ccCache.history);
  try {
    const res = await fetch('/api/sessions?limit=500');
    const data = await res.json();
    ccCache.history = data;
    renderHistoryAgentFilter(data.agents);
    renderHistory(data);
  } catch (err) {
    document.getElementById('historyList').innerHTML = `<div class="browse-item-desc">Failed to load sessions</div>`;
  }
}

function renderHistoryAgentFilter(agents) {
  // Pre-select the filter tab matching the selected agent
  ccFilters.historyAgent = selectedAgentId;
  const container = document.getElementById('historyAgentFilter');
  container.innerHTML = `
    <button class="filter-tab" onclick="setHistoryAgent(null, this)">All</button>
    ${agents.map(a => `<button class="filter-tab ${a === selectedAgentId ? 'active' : ''}" onclick="setHistoryAgent('${a}', this)">${a}</button>`).join('')}
  `;
}

function setHistoryAgent(agent, btn) {
  ccFilters.historyAgent = agent;
  document.querySelectorAll('#historyAgentFilter .filter-tab').forEach(t => t.classList.remove('active'));
  btn.classList.add('active');
  if (ccCache.history) renderHistory(ccCache.history);
}

function cleanSessionPreview(raw) {
  if (!raw) return '(empty session)';
  return raw
    .replace(/\[Chat messages since your last reply[^\]]*\]\s*/gi, '')
    .replace(/\[Current message[^\]]*\]\s*/gi, '')
    .replace(/^(User|Assistant|System):\s*/gi, '')
    .replace(/^\[.*?\]\s*/g, '')
    .replace(/\bAssistant:\s*/gi, '')
    .replace(/\bUser:\s*/gi, '')
    .replace(/\bSystem:\s*/gi, '')
    .replace(/\s+/g, ' ')
    .trim() || '(empty session)';
}

function renderHistory(data) {
  const search = ccFilters.historySearch.toLowerCase();
  let sessions = data.sessions;

  if (ccFilters.historyAgent) {
    sessions = sessions.filter(s => s.agent === ccFilters.historyAgent);
  }
  if (search) {
    sessions = sessions.filter(s => s.preview.toLowerCase().includes(search) || s.id.includes(search));
  }

  document.getElementById('historyCount').textContent = `${sessions.length}`;
  const list = document.getElementById('historyList');

  // Group by date
  const groups = {};
  for (const s of sessions) {
    const date = (s.timestamp || s.modifiedAt || '').slice(0, 10) || 'Unknown';
    if (!groups[date]) groups[date] = [];
    groups[date].push(s);
  }

  let html = '';
  for (const [date, items] of Object.entries(groups)) {
    const d = new Date(date + 'T00:00:00');
    const label = isNaN(d) ? date : d.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
    html += `<div class="history-date-header">${label}</div>`;
    for (const s of items) {
      const time = (s.timestamp || '').slice(11, 16) || '';
      const preview = cleanSessionPreview(s.preview);
      const model = s.model ? s.model.split('/').pop().replace('claude-', '').replace('opus-4-6', 'opus').replace('sonnet-4', 'sonnet') : '';
      const cost = s.totalCost > 0 ? `$${s.totalCost.toFixed(2)}` : '';

      html += `
        <div class="browse-item history-item" onclick="openSessionDetail('${s.agent}', '${s.id}')">
          <div class="history-item-top">
            <span class="browse-tag ${s.agent}">${s.agent}</span>
            <span class="history-time">${time}</span>
          </div>
          <div class="history-preview">${escapeHtml(preview.slice(0, 90))}</div>
          <div class="history-meta">
            <span>${s.messageCount} msgs</span>
            ${cost ? `<span>${cost}</span>` : ''}
            ${model ? `<span>${model}</span>` : ''}
          </div>
        </div>
      `;
    }
  }

  list.innerHTML = html || '<div class="browse-item-desc" style="padding:12px">No sessions found</div>';
}

function filterHistory() {
  ccFilters.historySearch = document.getElementById('historySearch').value;
  if (ccCache.history) renderHistory(ccCache.history);
}

async function openSessionDetail(agent, id) {
  try {
    const res = await fetch(`/api/sessions/${agent}/${id}`);
    const session = await res.json();

    let content = '';

    // Summary bar
    content += `<div class="status-grid">
      <div class="status-card"><div class="status-card-label">Messages</div><div class="status-card-value">${session.messageCount}</div></div>
      <div class="status-card"><div class="status-card-label">Model</div><div class="status-card-value" style="font-size:14px">${session.model || '—'}</div></div>
      <div class="status-card"><div class="status-card-label">Cost</div><div class="status-card-value">$${(session.totalCost || 0).toFixed(4)}</div></div>
    </div>`;

    // Transcript
    content += `<div class="detail-section"><div class="detail-section-title">Transcript</div>`;
    for (const msg of (session.transcript || [])) {
      const roleClass = msg.role === 'user' ? 'user' : 'assistant';
      const text = msg.content || '';
      // Truncate very long messages
      const display = text.length > 3000 ? text.slice(0, 3000) + '\n\n… (truncated)' : text;
      content += `
        <div class="transcript-msg">
          <div class="transcript-msg-role ${roleClass}">${msg.role}${msg.model ? ' · ' + msg.model : ''}</div>
          <div class="transcript-msg-content">${escapeHtml(display)}</div>
          ${msg.timestamp ? `<div class="transcript-msg-meta">${new Date(msg.timestamp).toLocaleString()}</div>` : ''}
        </div>
      `;
    }
    content += '</div>';

    const date = session.timestamp ? new Date(session.timestamp).toLocaleString() : '—';
    showDetailView(`${agent} session`, `${date} · ${session.messageCount} messages`, content);
  } catch {
    showDetailView('Session', 'Error', '<p>Failed to load session</p>');
  }
}

// ── Cron ──

async function loadCron() {
  try {
    const res = await fetch('/api/cron');
    const data = await res.json();
    ccCache.cron = data.jobs;
    renderCron(data.jobs);
  } catch {
    document.getElementById('cronList').innerHTML = `<div class="browse-item-desc">Failed to load cron jobs</div>`;
  }
}

function renderCron(jobs) {
  document.getElementById('cronCount').textContent = `${jobs.length}`;
  const list = document.getElementById('cronList');

  list.innerHTML = jobs.map(job => {
    const lastRun = job.lastRun ? new Date(job.lastRun).toLocaleString() : 'Never';
    const nextRun = job.nextRun ? new Date(job.nextRun).toLocaleString() : '—';
    return `
      <div class="cron-card">
        <div class="cron-card-header">
          <span class="cron-card-name">${job.name}</span>
          <span class="browse-tag ${job.enabled ? 'enabled' : 'disabled'}">${job.enabled ? 'active' : 'disabled'}</span>
        </div>
        <div class="cron-card-detail">
          <span class="browse-tag ${job.agentId}">${job.agentId}</span>
          ${job.scheduleHuman || job.schedule?.expr || ''}
        </div>
        <div class="cron-card-detail" style="margin-top:4px">
          Last: <span>${lastRun}</span>
          ${job.lastDuration ? ` · ${job.lastDuration}s` : ''}
          ${job.lastStatus ? ` · ${job.lastStatus}` : ''}
        </div>
        <div class="cron-card-detail">
          Next: <span>${nextRun}</span>
        </div>
      </div>
    `;
  }).join('');
}

// ── Projects ──

async function loadProjects() {
  if (ccCache.projects) return renderProjects(ccCache.projects);
  try {
    const res = await fetch(`/api/projects?agent=${selectedAgentId}`);
    const data = await res.json();
    ccCache.projects = data.projects;
    renderProjects(data.projects);
  } catch {
    document.getElementById('projectsList').innerHTML = `<div class="browse-item-desc">Failed to load projects</div>`;
  }
}

function renderProjects(projects) {
  const search = ccFilters.projectsSearch.toLowerCase();
  const filtered = search
    ? projects.filter(p => p.name.toLowerCase().includes(search) || (p.description || '').toLowerCase().includes(search))
    : projects;

  document.getElementById('projectsCount').textContent = `${filtered.length}`;
  const list = document.getElementById('projectsList');

  list.innerHTML = filtered.map(p => `
    <div class="browse-item" onclick="openProjectDetail('${p.id}')">
      <div class="browse-item-title">
        ${escapeHtml(p.name)}
        ${p.markers.map(m => `<span class="browse-tag ${m}">${m}</span>`).join('')}
      </div>
      <div class="browse-item-desc">${escapeHtml(p.description || 'No description')}</div>
      <div class="browse-item-meta">
        <span>${p.workspace}</span>
        ${p.version ? `<span>v${p.version}</span>` : ''}
        ${p.lastCommit ? `<span>${p.lastCommit.message?.slice(0, 40) || ''}</span>` : ''}
      </div>
    </div>
  `).join('');
}

function filterProjects() {
  ccFilters.projectsSearch = document.getElementById('projectsSearch').value;
  if (ccCache.projects) renderProjects(ccCache.projects);
}

async function openProjectDetail(id) {
  try {
    const res = await fetch(`/api/projects/${id}`);
    const project = await res.json();

    let content = '';
    content += `<div class="status-grid">
      <div class="status-card"><div class="status-card-label">Workspace</div><div class="status-card-value" style="font-size:14px">${project.workspace}</div></div>
      ${project.version ? `<div class="status-card"><div class="status-card-label">Version</div><div class="status-card-value" style="font-size:14px">${project.version}</div></div>` : ''}
      <div class="status-card"><div class="status-card-label">Stack</div><div class="status-card-value" style="font-size:14px">${project.markers.join(', ') || '—'}</div></div>
    </div>`;

    if (project.gitRemote) {
      content += `<div class="detail-section"><div class="detail-section-title">Git Remote</div><p><a href="${project.gitRemote}" target="_blank" style="color:var(--accent)">${project.gitRemote}</a></p></div>`;
    }

    if (project.lastCommit) {
      content += `<div class="detail-section"><div class="detail-section-title">Last Commit</div><p><code>${project.lastCommit.hash}</code> — ${escapeHtml(project.lastCommit.message || '')}<br><span style="color:var(--text-tertiary)">${project.lastCommit.date || ''}</span></p></div>`;
    }

    if (project.files && project.files.length) {
      content += `<div class="detail-section"><div class="detail-section-title">Files</div><pre>${project.files.join('\n')}</pre></div>`;
    }

    if (project.readme) {
      content += `<div class="detail-section"><div class="detail-section-title">README</div><div>${renderMarkdownBasic(project.readme)}</div></div>`;
    }

    showDetailView(project.name, `${project.path}`, content);
  } catch {
    showDetailView(id, 'Error', '<p>Failed to load project</p>');
  }
}

// ── Memory ──

async function loadMemory() {
  if (ccCache.memory) return renderMemory(ccCache.memory);
  try {
    const res = await fetch(`/api/memory?agent=${selectedAgentId}`);
    const data = await res.json();
    ccCache.memory = data.files;
    renderMemory(data.files);
  } catch {
    document.getElementById('memoryList').innerHTML = `<div class="browse-item-desc">Failed to load memory files</div>`;
  }
}

function renderMemory(files) {
  document.getElementById('memoryCount').textContent = `${files.length}`;
  const list = document.getElementById('memoryList');

  // Group by type
  const typeOrder = ['core', 'context', 'daily', 'document', 'genome', 'identity', 'data', 'other'];
  const groups = {};
  for (const f of files) {
    const t = f.type || 'other';
    if (!groups[t]) groups[t] = [];
    groups[t].push(f);
  }

  let html = '';
  for (const type of typeOrder) {
    const items = groups[type];
    if (!items || !items.length) continue;
    html += `<div style="font-size:10px;color:var(--text-tertiary);padding:10px 12px 4px;letter-spacing:0.1em;text-transform:uppercase">${type}</div>`;
    for (const f of items) {
      const size = f.size > 1024 ? `${(f.size / 1024).toFixed(1)}KB` : `${f.size}B`;
      const modified = f.modifiedAt ? new Date(f.modifiedAt).toLocaleDateString() : '';
      html += `
        <div class="browse-item" onclick="openMemoryDetail('${encodeURIComponent(f.id)}')">
          <div class="browse-item-title">
            <span class="memory-type-badge ${f.type}"></span>
            ${f.name}
          </div>
          <div class="browse-item-meta">
            <span>${size}</span>
            <span>${modified}</span>
          </div>
        </div>
      `;
    }
  }

  list.innerHTML = html || '<div class="browse-item-desc" style="padding:12px">No memory files found</div>';
}

async function openMemoryDetail(encodedId) {
  const id = decodeURIComponent(encodedId);
  try {
    const res = await fetch(`/api/memory/${id}?agent=${selectedAgentId}`);
    const data = await res.json();
    const modified = data.modifiedAt ? new Date(data.modifiedAt).toLocaleString() : '';
    const size = data.size > 1024 ? `${(data.size / 1024).toFixed(1)}KB` : `${data.size}B`;
    showDetailView(id, `${size} · ${modified}`, `<div>${renderMarkdownBasic(data.content)}</div>`);
  } catch {
    showDetailView(id, 'Error', '<p>Failed to load memory file</p>');
  }
}

// ── Journal ──

async function loadJournal(forceRefresh) {
  if (ccCache.journal && !forceRefresh) return renderJournal(ccCache.journal);
  try {
    const res = await fetch(`/api/journal?agent=${selectedAgentId}`);
    const data = await res.json();
    ccCache.journal = data;
    renderJournal(data);
  } catch {
    document.getElementById('journalList').innerHTML = `<div class="browse-item-desc">Failed to load journal</div>`;
  }
  // Start polling if on journal tab
  startJournalPoll();
}

function startJournalPoll() {
  if (journalPollTimer) clearInterval(journalPollTimer);
  journalPollTimer = setInterval(() => {
    if (currentPanel === 'journal') loadJournal(true);
    else { clearInterval(journalPollTimer); journalPollTimer = null; }
  }, 60000);
}

// Journal state
let journalEntries = [];      // currently visible (flattened, filtered, sorted)
let journalAllEntries = [];   // ALL entries flattened from raw data
let journalFilter = 'all';
let journalSortMode = 'recent';
let journalPageSize = 50;
let journalShown = 0;
let journalRawData = null;

function renderJournal(data) {
  journalRawData = data;
  const s = data.stats || {};
  document.getElementById('journalCount').textContent = s.thoughts_today != null ? `${s.thoughts_today} today` : '—';

  document.getElementById('journalStats').innerHTML = `
    <span class="journal-stat"><strong>${s.total_thoughts || 0}</strong> thoughts</span>
    <span class="journal-stat"><strong>${s.total_memories || 0}</strong> memories</span>
    <span class="journal-stat"><strong>${s.total_published || 0}</strong> published</span>
  `;

  // Flatten ALL entries into one array
  const sections = data.sections || {};
  journalAllEntries = [];

  for (const t of (sections.recent_thoughts || [])) {
    journalAllEntries.push({ type: 'thought', data: t, created: t.created || '', salience: t.salience || 0 });
  }
  for (const d of (sections.dreams || [])) {
    journalAllEntries.push({ type: 'dream', data: d, created: d.created || '', salience: 0.9 });
  }
  for (const q of (sections.questions || [])) {
    journalAllEntries.push({ type: 'question', data: q, created: q.created || '', salience: q.salience || 0 });
  }
  for (const p of (sections.published || [])) {
    journalAllEntries.push({ type: 'published', data: p, created: p.published_at || '', salience: 1.0 });
  }
  for (const d of (sections.decay || [])) {
    if (d.content_preview || d.action) {
      journalAllEntries.push({ type: 'decay', data: d, created: d.timestamp || '', salience: 0 });
    }
  }

  applyJournalFilters();
}

function applyJournalFilters() {
  // Filter
  let filtered = journalAllEntries;
  if (journalFilter !== 'all') {
    filtered = journalAllEntries.filter(e => e.type === journalFilter);
  }

  // Sort
  if (journalSortMode === 'salience') {
    filtered = [...filtered].sort((a, b) => b.salience - a.salience);
  } else {
    filtered = [...filtered].sort((a, b) => (b.created || '').localeCompare(a.created || ''));
  }

  journalEntries = filtered;
  journalShown = 0;
  document.getElementById('journalList').innerHTML = '';
  loadMoreJournal();

  // Update filter pill counts
  document.querySelectorAll('.journal-filter-pill').forEach(btn => {
    const f = btn.dataset.filter;
    btn.classList.toggle('active', f === journalFilter);
    const count = f === 'all' ? journalAllEntries.length : journalAllEntries.filter(e => e.type === f).length;
    const label = btn.textContent.replace(/\s*\(\d+\)/, '');
    btn.textContent = `${label} (${count})`;
  });

  // Update sort buttons
  document.querySelectorAll('.journal-sort-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.sort === journalSortMode);
  });
}

function filterJournal(filter) {
  journalFilter = filter;
  applyJournalFilters();
}

function sortJournal(mode) {
  journalSortMode = mode;
  applyJournalFilters();
}

function loadMoreJournal() {
  const list = document.getElementById('journalList');
  const loadMoreBtn = document.getElementById('journalLoadMore');
  const end = Math.min(journalShown + journalPageSize, journalEntries.length);
  let html = '';

  for (let i = journalShown; i < end; i++) {
    const entry = journalEntries[i];
    const { type, data } = entry;
    let preview, time, badge, badgeClass, extraStyle = '';

    if (type === 'thought') {
      preview = (data.content || '').slice(0, 100) + (data.content?.length > 100 ? '…' : '');
      time = data.time_ago || '';
      badge = data.source || 'thought';
      badgeClass = data.source || 'background';
    } else if (type === 'dream') {
      preview = (data.content || '').slice(0, 100) + (data.content?.length > 100 ? '…' : '');
      time = data.time_ago || '';
      badge = 'dream';
      badgeClass = 'dream';
    } else if (type === 'question') {
      preview = '❓ ' + ((data.content || '').slice(0, 100) + (data.content?.length > 100 ? '…' : ''));
      time = data.time_ago || '';
      badge = 'question';
      badgeClass = 'question';
    } else if (type === 'published') {
      preview = (data.text || '').slice(0, 100) + (data.text?.length > 100 ? '…' : '');
      time = data.time_ago || '';
      badge = 'published';
      badgeClass = 'published';
    } else if (type === 'decay') {
      preview = data.content_preview || `${data.action || 'decay'} event`;
      time = data.time_ago || '';
      badge = data.action || 'decay';
      badgeClass = data.action || 'soften';
      extraStyle = ' style="opacity:0.7"';
    }

    html += `
      <div class="journal-item" onclick="openJournalEntry(${i})">
        <div class="journal-item-preview"${extraStyle}>${escapeHtml(preview)}</div>
        <div class="journal-item-meta">
          <span class="journal-item-time">${escapeHtml(time)}</span>
          <span class="journal-badge ${badgeClass}">${badge}</span>
        </div>
      </div>`;
  }

  journalShown = end;
  list.insertAdjacentHTML('beforeend', html);

  if (journalShown < journalEntries.length) {
    loadMoreBtn.style.display = 'block';
    loadMoreBtn.textContent = `Load more… (${journalEntries.length - journalShown} remaining)`;
  } else {
    loadMoreBtn.style.display = 'none';
  }

  if (!journalEntries.length) {
    list.innerHTML = '<div class="browse-item-desc" style="padding:12px">No entries match this filter</div>';
  }
}

function openJournalEntry(idx) {
  const entry = journalEntries[idx];
  if (!entry) return;

  // Highlight active item
  document.querySelectorAll('.journal-item').forEach((el, i) => {
    el.classList.toggle('active', i === idx);
  });

  const { type, data } = entry;
  let title, subtitle, contentHtml;

  if (type === 'thought') {
    title = data.source ? data.source.charAt(0).toUpperCase() + data.source.slice(1) : 'Thought';
    subtitle = data.time_ago || '';
    const tagsHtml = (data.tags || []).map(tag => `<span class="journal-tag">${escapeHtml(tag)}</span>`).join(' ');
    contentHtml = `
      <div class="journal-detail-content">${escapeHtml(data.content)}</div>
      <div class="journal-detail-meta">
        ${data.source ? `<span class="journal-badge ${data.source}">${data.source}</span>` : ''}
        ${data.salience != null ? `<span class="journal-badge background">salience ${data.salience.toFixed(2)}</span>` : ''}
        ${data.delivered ? '<span class="journal-badge published">delivered</span>' : ''}
        ${data.published ? '<span class="journal-badge published">published</span>' : ''}
      </div>
      ${tagsHtml ? `<div class="journal-detail-tags">${tagsHtml}</div>` : ''}`;
  } else if (type === 'dream') {
    title = 'Dream';
    subtitle = data.time_ago || '';
    const tagsHtml = (data.tags || []).map(tag => `<span class="journal-tag">${escapeHtml(tag)}</span>`).join(' ');
    contentHtml = `
      <div class="journal-detail-dream">
        <div class="journal-detail-content">${escapeHtml(data.content)}</div>
      </div>
      ${tagsHtml ? `<div class="journal-detail-tags" style="margin-top:12px">${tagsHtml}</div>` : ''}`;
  } else if (type === 'question') {
    title = 'Question';
    subtitle = data.time_ago || '';
    contentHtml = `
      <div class="journal-detail-content">❓ ${escapeHtml(data.content)}</div>
      <div class="journal-detail-meta">
        ${data.salience != null ? `<span class="journal-badge question">salience ${data.salience.toFixed(2)}</span>` : ''}
      </div>`;
  } else if (type === 'published') {
    title = 'Published to X';
    subtitle = data.time_ago || '';
    const link = data.tweet_id ? `<a class="journal-detail-tweet-link" href="https://x.com/polyphonicchat/status/${data.tweet_id}" target="_blank">View on X →</a>` : '';
    contentHtml = `
      <div class="journal-detail-content">${escapeHtml(data.text)}</div>
      <div class="journal-detail-meta">
        <span class="journal-badge published">published</span>
        ${link}
      </div>`;
  } else if (type === 'decay') {
    title = 'Memory Decay';
    subtitle = data.time_ago || '';
    contentHtml = `
      <div class="journal-detail-content">${escapeHtml(data.content_preview || '')}</div>
      <div class="journal-detail-meta">
        ${data.action ? `<span class="journal-badge ${data.action}">${data.action}</span>` : ''}
        <span class="journal-sharpness">${(data.old_sharpness || 0).toFixed(2)} <span class="arrow">→</span> ${(data.new_sharpness || 0).toFixed(2)}</span>
      </div>`;
  }

  showDetailView(title, subtitle, contentHtml);
}

// ── Detail View ──

function showDetailView(title, subtitle, contentHtml) {
  const messagesEl = document.getElementById('messages');
  const inputArea = document.querySelector('.input-area');
  const detailView = document.getElementById('detailView');
  const dashboardView = document.getElementById('dashboardView');

  // Hide chat elements and dashboard, show detail
  messagesEl.style.display = 'none';
  inputArea.style.display = 'none';
  dashboardView.style.display = 'none';
  detailView.classList.add('active');

  document.getElementById('detailContent').innerHTML = contentHtml;

  // Update breadcrumb with section > item
  const sectionLabel = sectionLabels[currentPanel] || currentPanel;
  updateBreadcrumb([sectionLabel, title]);

  // Store detail context
  viewState.detailContext = { section: currentPanel, title: title };

  // Scroll to top
  document.getElementById('detailContent').scrollTop = 0;
}

function closeDetailView() {
  const messagesEl = document.getElementById('messages');
  const inputArea = document.querySelector('.input-area');
  const detailView = document.getElementById('detailView');

  detailView.classList.remove('active');
  viewState.detailContext = null;

  // Restore appropriate view
  if (currentPanel === 'chat') {
    messagesEl.style.display = '';
    inputArea.style.display = '';
    updateBreadcrumb(['Chat']);
  } else {
    // For non-chat panels, main area stays empty (list is in sidebar)
    updateBreadcrumb([sectionLabels[currentPanel] || currentPanel]);
  }
}

// ── Markdown Basic Renderer (for detail views) ──

function renderMarkdownBasic(md) {
  if (!md) return '';
  // Strip YAML frontmatter
  md = md.replace(/^---\n[\s\S]*?\n---\n?/, '');
  let html = escapeHtml(md);

  // Headers
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

  // Bold and italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong style="color:var(--text-primary)">$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // Inline code
  html = html.replace(/`([^`]+)`/g, '<code style="background:rgba(255,255,255,0.06);padding:1px 5px;border-radius:3px;font-size:12px">$1</code>');

  // Code blocks
  html = html.replace(/```[\w]*\n([\s\S]*?)```/g, '<pre>$1</pre>');

  // Links
  html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" style="color:var(--accent)">$1</a>');

  // Horizontal rules
  html = html.replace(/^---$/gm, '<hr style="border:none;border-top:1px solid var(--border);margin:16px 0">');

  // Lists
  html = html.replace(/^- (.+)$/gm, '<li style="margin-left:16px;color:var(--text-secondary)">$1</li>');

  // Tables (basic)
  html = html.replace(/^\|(.+)\|$/gm, (match, content) => {
    const cells = content.split('|').map(c => c.trim());
    if (cells.every(c => c.match(/^[-:]+$/))) return ''; // separator row
    const tag = 'td';
    return '<tr>' + cells.map(c => `<${tag} style="padding:4px 8px;border:1px solid var(--border)">${c}</${tag}>`).join('') + '</tr>';
  });

  // Wrap consecutive <tr> in <table>
  html = html.replace(/((?:<tr>.*<\/tr>\s*)+)/g, '<table style="border-collapse:collapse;margin:12px 0;font-size:12px;width:100%">$1</table>');

  // Paragraphs (double newlines)
  html = html.replace(/\n\n/g, '</p><p>');
  html = '<p>' + html + '</p>';

  // Clean up empty paragraphs
  html = html.replace(/<p>\s*<\/p>/g, '');
  html = html.replace(/<p>(<h[123]>)/g, '$1');
  html = html.replace(/(<\/h[123]>)<\/p>/g, '$1');
  html = html.replace(/<p>(<pre>)/g, '$1');
  html = html.replace(/(<\/pre>)<\/p>/g, '$1');
  html = html.replace(/<p>(<hr[^>]*>)<\/p>/g, '$1');
  html = html.replace(/<p>(<table)/g, '$1');
  html = html.replace(/(<\/table>)<\/p>/g, '$1');
  html = html.replace(/<p>(<li)/g, '$1');
  html = html.replace(/(<\/li>)<\/p>/g, '$1');

  return html;
}

// ── escapeHtml helper (if not already defined) ──
if (typeof window._escapeHtmlDefined === 'undefined') {
  window._escapeHtmlDefined = true;
  if (typeof escapeHtml !== 'function') {
    window.escapeHtml = function(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    };
  }
}


// ══════════════════════════════════════════════
// ── Boot ──
// ══════════════════════════════════════════════
init();
initCanvasResize();

// Close artifact dropdown on outside click
document.addEventListener('click', (e) => {
  if (!e.target.closest('.canvas-artifact-select')) {
    closeArtifactDropdown();
  }
});

// Electron detection — add class for native app styling
if (window.vektor?.isElectron) {
  document.documentElement.classList.add('electron-app');
}
</script>

<!-- Notification panel - mounted at body level to escape all stacking contexts -->
<div class="notification-panel" id="notifPanel">
  <div class="notification-panel-header">
    <span>Notifications</span>
    <button onclick="clearAllNotifications()">Clear all</button>
  </div>
  <div class="notification-list" id="notifList">
    <div class="notification-empty">
      <div class="notification-empty-icon">⏀</div>
      No notifications
    </div>
  </div>
</div>

</body>
</html>